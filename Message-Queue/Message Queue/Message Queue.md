## 용어사전

**메시지 지향 미들웨어(Message Oriented Middleware : MOM)** 

* 분산 시스템 간 메시지를 주고 받는 기능을 지원하는 소프트웨어나 하드웨어 인프라

**메시지 큐(Message Queue : MQ)**

* MOM을 구현한 시스템

**브로커(Broker)**

* Message Queue 시스템

 **AMQP(Advanced Message Queueing Protocol)**

* 메시지 지향 미들웨어를 위한 프로토콜



## Message Queue

* MQ (Message Queue) 란 메시지 기반의 미들웨어로 메시지를 이용하여 여러 어플리케이션, 시스템, 서비스들을 연결해주는 솔루션이다.
* MOM를 구현한 솔루션으로 비동기 메시지를 사용하는 서비스들 사이에서 데이터를 교환해주는 역할을 한다.

![image-20210602221101816](.\images\image-20210602221101816.png)

**Message Queue**

`Message Queue`는 비동기 통신 프로토콜을 제공합니다. 이 프로토콜은 `Message` 를 `Message Queue`에 배치하고 처리를 계속하기 위해 즉각적인 응답을 필요로 하지 않는 시스템입니다. 이메일은 아마도 비동기 통신의 가장 좋은 예시 입니다. 메일이 전송될 때, 발신인은 수신자의 즉각적인 응답 없이 다른 일을 계속 처리합니다. 이러한 메시지 처리 방법은 생산자가 메시지 큐와 동시에 상호작용할 필요가 없도록 `Consumer`로부터 `Producer`를 분리합니다.



**Message** 

`Message` 는 송신자와 수신기 애플리케이션 간에 전송되는 데이터이며, 기본적으로 상단에 헤더가 있는 바이트 배열입니다. 메시지의 예로는 한 시스템에 작업 처리를 시작하도록 지시하는 것이 있을 수 있으며, 완료된 작업에 대한 정보를 포함하는 메시지일 수 있습니다.



**메시지 큐의 아키텍처**

메시지 큐의 기본 아키텍처는 간단합니다. `Message` 를 만들어 `Message Queue`에 전달하는 `Producer`라는 클라이언트 응용 프로그램이 있습니다. `Consumer`라고 하는 다른 응용 프로그램은 큐에 연결하여 처리할 `Message` 를 가져옵니다. 큐에 배치된 `Message` 는 `Consumer`가 검색하고 이를 사용해 어떤 작업을 수행할 때까지 `Message Queue`에 저장됩니다.

# Publish/subscribe messaging

Publish/subscribe messaging을 사용하면 해당 정보의 소비자와 정보 공급자를 분리할 수 있습니다. 송신 application과 수신 application은 정보를 주고 받기 위해 서로에 대해 아무것도 알 필요가 없습니다.

반대로 Point-to-point message queuing에서는 응용 프로그램이 다른 응용 프로그램에 메시지를 보내기 전에 해당 응용 프로그램에 대해 알아야 합니다. 예를 들어 정보를 보낼 대기열 이름을 알고 있어야 하며 대기열 관리자 이름을 지정할 수도 있습니다.

그림 1 간단한 게시/구독 구성

![큐 매니저가 표시되고 게시자와 구독자가 옆에 표시됩니다. 구독은 구독자에서 대기열 관리자로, 게시는 게시자에서 대기열 관리자를 통해 구독자로 흐릅니다.](https://www.ibm.com/docs/en/SSFKSJ_8.0.0/com.ibm.mq.pro.doc/q004870a.gif)

일반적인 게시/구독 시스템에는 여러 가지 다양한 주제에 대해 둘 이상의 게시자와 둘 이상의 구독자가 있으며, 종종 둘 이상의 대기열 관리자가 있습니다. 응용 프로그램은 게시자일 수도 있고 구독자일 수도 있습니다.

게시/구독 메시징과 포인트 투 포인트(point-to-point) 메시징의 또 다른 중요한 차이점은 포인트 투 포인트(point-to-point) 큐로 전송되는 메시지는 하나의 소모적인 응용 프로그램에 의해서만 처리된다는 것이다. 둘 이상의 가입자가 이자를 등록한 게시/구독 주제에 게시된 메시지는 모든 관심 가입자에 의해 처리됩니다.



## Message Queue 이점

**더 뛰어난 성능**

>  메시지 대기열은 비동기식 통신을 지원합니다. 즉, 메시지를 생산하고 소비하는 엔드포인트가 서로가 아니라 대기열과 상호 작용합니다. 생산자는 요청이 처리되길 기다리지 않고 이를 대기열에 추가할 수 있습니다. 소비자는 메시지가 제공될 때만 처리합니다. 시스템의 어떤 구성 요소도 다른 구성 요소를 기다리느라 지연되지 않으므로 데이터 흐름이 최적화됩니다.

**향상된 안정성**

> 대기열을 사용하면 데이터가 지속되고 시스템의 서로 다른 부분이 오프라인이 될 때 발생하는 오류를 줄일 수 있습니다. 서로 다른 구성 요소를 [메시지 대기열](https://aws.amazon.com/ko/sqs/)로 분리함으로써 내결함성을 강화할 수 있습니다. 시스템의 한 부분에 접속할 수 없더라도 다른 부분이 여전히 대기열과 계속 상호 작용할 수 있습니다. 대기열 자체 또한 미러링되어 더 뛰어난 가용성을 제공할 수 있습니다.

**세분화된 확장성**

>  메시지 대기열을 사용하면 정확히 필요한 곳을 확장할 수 있습니다. 워크로드가 피크에 도달하면, 애플리케이션의 여러 인스턴스가 충돌의 위험 없이 요청을 모두 대기열에 추가할 수 있습니다. 이러한 수신 요청으로 대기열이 길어지면 워크로드를 소비자 플릿 전체로 분산할 수 있습니다. 생산자, 소비자 및 대기열 자체가 필요에 따라 모두 확장되고 축소될 수 있습니다.

**간소화된 결합 해제**

> 메시지 대기열은 구성 요소 간 종속성을 제거하고 결합 해제된 애플리케이션의 코딩을 상당히 간소화합니다. 소프트웨어 구성 요소는 통신 코드의 영향을 받지 않으며, 개별적인 비즈니스 기능을 수행하도록 설계될 수 있습니다.
> 모놀리식 애플리케이션, 마이크로 서비스 또는 서버리스 아키텍처 중 어떤 것을 사용하고 있든 메시지 대기열은 분산 시스템을 결합 해제할 수 있는 아주 간단한 방법입니다.



## 언제 Message Queue를 사용할까?

1. 안정성, 고가용성을 위한 설계(즉각적인 업데이트는 보장하지 않음. 시스템에 확장성 필요. 데이터의 영속성 필요. 장애에 대한 복원력이 필요.)
2. 특정한 시간에만 tps가 튀는 등의 사례. 추가적으로 장비를 투입하는 것보다 효율적인 방안이 필요한 경우
3. 같은 IDC 안에서 메세지가 전송되는 등의 조건 하에 HTTP 프로토콜의 오버헤드가 큐를 사용할 때 증가하는 네트워크 레이턴시보다 커지는 경우
4. 사용할 수 있는 자원에 비해서 처리해야될 데이터 양이 지나치게 많아 대응이 필요할 때
5. 데이터가 생성되는 양에 비해서 소모되는 양이 눈에 띄게 차이나는 경우
6. 다수의 어플리케이션이 어떤 데이터 저장소를 공유할 필요성이 있을 때



##  MQ 대표 솔루션

1. Kafka
2. Rabbit MQ
3. IBM MQ
4. Apache ActiveMQ



## Kafka

- LinkedIn에서 구직정보들을 처리할수 있는 플랫폼으로 개발이 시작되었다.
- 실시간 로그 처리에 특화되어 설계된 시스템으로 개발되어 타 MQ 대비 TPS(transactions per second)가 매우 우수하나 특화된 솔루션이기 때문에 타 MQ 솔루션에서제공하는 다양한 기능들은 제공되지 않는다.
- AMQP(Advanced Message Queue Protocol), JMS 이 아닌 단순 메시지 헤더를 이용한 TCP 통신이다.
- MQ는 broker가 producer 에게 메세지를 받아서 consumer에게 push해 주는 방식인데 반해, Kafka는 consumer가 broker로부터 직접 메시지를 가지고 가는 pull 방식으로 동작하기 때문에 consumer는 자신의 처리능력만큼의 메시지만 broker로부터 가져오기 때문에 최적의 성능을 낼 수 있다.
- 많은 데이터 전송과 최대 처리량을 유지하기에 대량 데이터 스트리밍에 적합하다.
- 상태 변경이 시간순으로 기록되어하는 응용 프로그램인 이벤트 소싱(Evenet Sourcing) 저장소로 적합하다.



## Rabbit MQ

- 고성능을 목표로 AMQP 프로토콜을 사용하여 개발된 MQ 로 Erlang OTP 기반으로 개발되었다.
- 실시간 모니터링이 용이하고 다양한 언어 및 OS 지원, RabbitMQ 서버간 클러스터링이 가능하다.
- 얼랭 기반으로 높은 신뢰성과 분산 어플리케이션 구축 가능.
- Direct Exchange(Point to Point), Topic Exchange(Publish-Subscribe), Fanout Exchange(Multicast) 등의 라우팅 규칙 제공
- 뛰어난 범용성을 가지고 있음.
- 기본적으로 클러스터링 지원. 추가로 좀 더 높은 트래픽을 처리하기 위해 셔블, 페더레이션 플러그인 제공.



## IBM MQ

- 가장 많이 사용되는 상용 MQ 제품으로 표준 JMS 메시징 기반으로 MQTT 프로토콜을 지원한다.



## Apache ActiveMQ

- Java 기반의 JMS Queue 를 지원하는 오픈소스로 MQTT, AMQP, OpenWire, STOMP 프로토콜을 지원한다.
- 다양한 언어를 지원하며 클러스터링이 가능하다. 단, 모니터링 도구는 없다.
- JDBC를 사용하여 매우 빠른 Persitence 지원
- 클러스터링 가능
- REST API를 통해 웹기반 메시징 API를 지원하며 Ajax를 통해 순수한 DHTML을 사용한 웹스트리밍 지원을 한다.



참고

* https://sarc.io/index.php/miscellaneous/1615-message-queue-mq
* https://aws.amazon.com/ko/pub-sub-messaging/
* https://aws.amazon.com/ko/message-queue/
* https://aws.amazon.com/ko/message-queue/benefits/