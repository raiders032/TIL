## 보조 기억 장치

* 사용자가 원하는 데이터를 검색하기 위해서는 DBMS는 디스크 상의 데이터베이스로부터 사요자가 원하는 데이터를 포함하고 있는 블록을 읽어서 주기억 장치로 가져옴
* 데이터가 변경된 경우에 블록들은 디스크에 다시 기록함



## 파일 조직

힙 파일

* 레코드들이 삽입된 순서대로 파일에 저장됨
* 레코드를 찾기 위해서는 모든 레코드들은 순차적으로 접근해야함
* 원하는 레코드를 찾은 후 그 레코드를 삭제하고 삭제된 레코드가 차지하던 공간을 재사용하지 않음
* 좋은 성능을 위해 힙 파일을 주기적으로 재조직 해야한다.

| 연산             | 시간   |
| ---------------- | ------ |
| 삽입             | 효율   |
| 삭제             | 비효율 |
| 탐색             | 비효율 |
| 순서대로 탐색    | 비효율 |
| 특정 레코드 탐색 | 비효율 |

순차 파일

* 레코드들이 하나 이상의 필드 값에 따라 순서대로 저장된 파일
* 레코드들이 탐색 키 값의 순서에 따라 저장된다.
* 탐색 키는 순차 파일을 정렬하는데 사용되는 필드를 의미한다.
* 삽입시 레코드 순서를 고려 시간이 많이 소요된다
* 삭제시 레코드가 사용하던 공간이 빈공간으로 남아 주기적인 재조직이 필요하다

| 연산                               | 시간   |
| ---------------------------------- | ------ |
| 삽입                               | 비효율 |
| 삭제                               | 비효율 |
| 탐색키를 기반으로 검색             | 효율   |
| 탐색키가 아닌 필드를 사용하여 탐색 | 비효율 |



## 인덱스

* 인덱스랑 원하는 데이터의 조회 성능을 향상시키고 싶을 때 사용한다.
  * 예시) 책의 색인
* 인덱스 파일은 인덱스 엔트리라고 불리는 레코드를 가지고있다
* 인덱스 엔트리는 <탐색 키, 포인터> 의 구조를 가지고 있다
  * 탐색 키: 레코드를 찾고자 할 때 사용되는 애트리뷰트의 집합이다.
  * 포인터: 데이터의 위치
* 인덱스 파일은 일반적으로 데이터 파일에 비하면 훨씬 작다
* 인덱스에는 크게 두가지 종류가 있다.
  * Ordered: 탐색키가 정렬된 순서로 저장된 형태
  * Hash: 탐색키가 해시 함수를 이용해 버켓에 분산된 형태
* 인덱스는 데이터 파일과는 별도의 파일에 저장한다.
* 하나의 파일에 여러개의 인덱스를 정의할 수 있다.



## 인덱스 평가 척도

* 지원 타입(Access types supported)
  * 정확한 매칭을 지원하는지(Exact match query)
  * 범위 질위를 지원하는지(Range query)
* 조회 시간
* 삽입 시간
* 삭제 시간
* 공간



## 기본 인덱스(Primary Index)

* clustering Index
* 인덱스의 탐색 키 값에 따라 데이터 파일도 정렬되어 있는 경우를 말한다.
  * 따라서 각 릴레이션마다 최대 한개의 기본 인덱스를 가질 수 있다.
* Sparse index
  * 희소 인덱스는 각 데이터 블록마다 한 개의 엔트리를 갖는다
  * 데이터 파일이 정렬되어 있을 때 가능하다
  * 적은 공간을 차지하고 삽입과 삭제시 maintenance overhead가 보조 인덱스에 비해 적다
  * 일반적으로 레코드를 찾을때 보조 인덱스에 비해 느리다
* 레코드를 순서대로 탐색할 때 효율적이다



## 보조 인덱스(Secondary Index)

* non-clustering Index
* 인덱스의 탐색 키 값에 따라 데이터 파일이 정렬되어 있는 않은 경우를 말한다.
* Dense index
  * 밀집 인덱스는 레코드마다 한 개의 엔트리를 갖는다.
* 보조 인덱스는 일반적으로 밀집 인덱스이므로 같은 수의 레코드들을 접근할 때 보조 인덱스를 통하면 기본 인덱스를 통하는 경유보다 디스크 접근 횟수가 증가 할 수 있다.
* 레코드를 순서대로 탐색할 때 비효율적이다



## 단일 단계 인덱스

* 단일 단계 인덱스란 순차 파일을 인덱싱해서 인덱스를 통해 임의의 레코드를 접근할 수 있는 파일

  

## 다단계 인덱스(Mutilevel Index)

* 인덱스 자체가 클 경유 인덱스 탐색 자체에도 시간이 걸림 이러한 시간을 줄이기 위해 단일 단계 인덱스를 디스크 상의 하나릐 순서 파일로 간주하고 단일 단계 인덱스에 대해서 다시 인덱스를 정의한다.
* 이 과정을 모든 인덱스 엔트리들이 한 블록에 들어갈 수 있을 때까지 반복한다.
* 가장 상위 단계 인덱스를 마스터 인덱스라고 부른다.
* 마스터 인덱스는 한 블록이라 주기억 장치에 상주할 수 있다.
* 대부분의 다단계 인덱스는 B+트리를 사용한다.



## 인덱스의 장점과 단점

장점

* 검색 속도가 향상된다.

단점

* 인덱스를 저장하기위한 공간이 추가적으로 필요하다.
* 삽입, 삭제, 수정 연산의 속도가 저하된다.



## 인덱스를 어디에 적용해야 되나?



인덱스를 결정하는데 도움되는 지침

1. 기본 키는 클러스터링 인덱스를 정의할 훌륭한 후보
2. 외래 키도 인덱스를 정의할 중요한 후보
3. 한 애트리뷰트에 들어있는 상이한 값들의 개수가 거의 전체 레코드 수와 비슷하고 그 애트리뷰트가 동등 조건에 사용된다면 비클러스터링 인덱스를 생성하는 것이 좋음
4. 튜플이 많이 들어 있는 릴레이션에서 대부분의 질의가 검색하는 튜플이 2%~4% 미만인 경우에는 인덱스를 생성
5. 자주 갱신되는 애트리뷰트에는 인덱스를 정의하지 않는 것이 좋다.
6. 갱신이 빈번하게 이루어지는 릴레이션에는 인덱스를 많이 만드는 것을 피한다.
7. 대량의 데이터를 삽입할 때는 인덱스를 제거하고 데이터 삽입이 끝난 후에 다시 생성하는 것이 좋다.
8. ORDER BY, GROUP BY 절에 자주 사용되는 애트리뷰트는 인덱스를 정의할 후보



## B+Tree

* 모든 DB에서 인덱스를 구현하기 위헤 사용한다.
* B+Tree는 다음을 만족한다.
  * 균형잡힌 트리이기 때문에 루트에서 리프 노드까지의 거리가 모두 같다
  * 루트와 리프를 제외한 모든 노드는 `n/2~n` 개의 자식 노드를 가져야한다.
  * 리프 노드는 `(n-1)/2 ~ n-1` 개의 값을 가진다.
  * 특수 케이스
    * 루드 노드가 리프가 아니면 적어도 2개의 자식을 갖는다
    * 루트 노드가 리프 노드이면(트리에 노드가 하나이면) 루트 노드는 `0 ~ n-1` 개의 값을 가진다.



참고

* http://www.kocw.net/home/search/kemView.do?kemId=1154374
* http://www.kocw.net/home/search/kemView.do?kemId=1173887
* http://www.kocw.net/home/search/kemView.do?kemId=1064626