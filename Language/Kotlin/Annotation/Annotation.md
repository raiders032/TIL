# 1 Annotation

- 코틀린의 애노테이션 개념과 자바와 마찬가지다.
  -  [Annotation.md](../../Java/Annotation/Annotation.md)  참고
- 애노테이션은 메타데이터라고 볼 수 있다. 
- 메타데이터란 애플리케이션이 처리해 할 데이터가 아니라 **컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지 알려주는 정보**이다.



# 2 메타 Annotation

- 애노테이션 클래스에도 애노테이션을 붙일 수 있다.
- 애노테이션 클래스에 적용할 수 있는 애노테이션을 메타 애노테이션이라고 한다.



## 2.1 @Target

* 어노테이션을 적용할 수 있는 대상은 `java.lang.annotation.ElementType` 열거 상수로 아래와 같이 정의되어 있다.
* 어노테이션 적용될 대상을 지정할 때에는 `@Target` 어노테이션을 사용한다.

| Enum Constant     | 적용 대상                     |
| :---------------- | :---------------------------- |
| `TYPE`            | 클래스, 인터페이스, 열거 타입 |
| `ANNOTATION_TYPE` | 어노테이션                    |
| `CONSTRUCTOR`     | 생성자                        |
| `FIELD`           | 필드                          |
| `LOCAL_VARIABLE`  | 로컬 변수                     |
| `METHOD`          | 메소드                        |



## 2.2 @Retention

* 어노테이션 정의 시 사용 용도에 따라 어느 범위까지 유지할 것인지 설정한다.
  * 소스상에서만 유지
  * 컴파일 클래스까지 유지
  * 런타임 시에도 유지
* 어노테이션 유지 정책은 `java.lang.annotation.RetentionPolicy` 에 아래와 같은 열거 상수로 정의되어 있다.
* `@Retention` 어노테이션을 사용해서 유지 정책을 지정한다.
  * 자바에서는 `CLASS`로 지정되어 런타임엔 사용할 수 없다.
  * 코틀린에서는 기본적으로 `RUNTIME`으로 지정한다.


| Enum Constant | Description                                                  |
| :------------ | :----------------------------------------------------------- |
| `CLASS`       | 바이트 코드 파일까지 어노테이션 정보를 유지한다. 하지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수 없다. |
| `RUNTIME`     | 바이트 코드 파일 까지 어노테이션을 유지하면서 리플렉션을 이용해서 런타임 시에 어노테이션 정보를 얻을 수 있다. |
| `SOURCE`      | 소스상에서만 어노테이션 정보를 유지한다. 소스 코드를 분석할 때만 의미가 있으며, 바이트 코드 파일에는 정보가 남지 않는다. |



# 3 Annotation 선언

- 애노테이션 클래스 선언은 annotaion 변경자를 class 앞에 붙이면 된다.



# 4 자바와 차이점

- 클래스를 애노테이션 인자로 지정할 때는 클래스 이름 뒤에 `::class`를 붙인다.
- 다른 애노테이션을 인자로 지정할 때는 애노테이션 이름 앞에 `@`를 붙이지 않는다.
- 배열을 인자로 지정하려면 `arrayOf` 함수를 사용한다.
  - arrayOf 함수를 사용했더니 인텔리제이에서 다음과 같은 메시지를 보여준다. 
  - `'arrayOf' call should be replaced with array literal [...]`
  - `arrayOf` 대신 `[]`를 사용하자
- 애노테이션 인자는 컴파일 시점에 알 수 있어야한다.
  - 따라서 임의의 프로퍼티를 인자로 사용할 수 없다.
  - 프로퍼티를 인자로 사용하고 싶다면 프로퍼티 앞에 `const` 변경자를 붙여야 한다.
  - `const`가 붙은 프로퍼티를 컴파일 시점 상수로 취급한다.



# 5 사용 지점 대상

- 코틀린 소스코드에서 한 선언을 컴파일 하면 여러 자바 선언과 대응되는 경우가 있다.
  - 예를 들어 코틀린 프로퍼티는 자바 필드와 게터 메서드 선언과 대응된다.
- 따라서 애노테이션을 붙일 때 이런 요소 중 어떤 요소에 애노테이션을 붙일지 표시할 필요가 있다.
- 사용 지점 대상은 `@<사용 지점 대상>:<애노테이션 이름>`과 같이 지정한다.
  - 예) `@get:Rule` -> 프로퍼티 게터에 @Rule 애노테이션을 적용하라
- 자바에서 선언된 애노테이션을 프로퍼티에 붙이는 경우 기본적으로 프로퍼티의 필드에 그 애노테이션이 붙는다.



**사용 지점 대상**

- property: 프로퍼티 전체. 자바에서 선언된 애노테이션에는 지정 불가
- field: 프로퍼티에 의해 생성되는 필드
- get: 프로퍼티 게터
- set: 프로퍼티 세터
- receiver: 확장 함수나 프로퍼티의 수신 객체
- param: 생성자 파라미터
- setparam: 세터 파라미터
- delegate: 위임 프로퍼티의 위림 인스턴스를 담아둔 필드
- File: 파일 안에 선언된 최상위 함수와 프로퍼티를 담아두는 클래스