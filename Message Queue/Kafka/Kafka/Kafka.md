# 1. Kafka

* 대용량, 대규모 메시지 데이터를 빠르게 처리하도록 개발된 메시지 플랫폼

# 2. 카프카 용어 간단 정리

**kafka**

* 아파치 프로젝트 애플리케이션 이름
* 클러스터 구성이 가능하며, 카프카 클러스터라고 부른다.

**broker**

* 카프카 애플리케이션이 설치되어있는 서버 또는 노드를 말한다.

**Publisher(Producer)**

* 메시지를 생상하여 브로커의 토픽 이름으로 보내는 서버 또는 애플리케이션을 말한다.

**Subscriber(consumer)**

* 브로커의 토픽 이름으로 저장된 메시지를 가져가는 서버 또는 애플리케이션을 말한다.

**Topic**

* 카프카에서 메시지를 구분하기 위해 사용되는 이름이다.
* 1개 이상의 파티션을 소유하고 있다

**Partition**

* 병렬처리가 가능하도록 토픽을 나눌 수 있고, 많은 양의 메시지 처리를 위해 파티션의 수를 늘려줄 수 있습니다.
* 파티션에는 프로듀서가 보낸 데이터들이 들어가 있으며 이 데이터를 레코드라고 한다.

**Record**

* 파티션에는 프로듀서가 보낸 데이터들이 들어가 있으며 이 데이터를 레코드라고 한다.
* 레코드는 타임스탬프, 메시지 키, 메시지 값, 오프셋으로 구성되어 있다.

**Pub/Sub**

* `Publisher`가 카프카에 토픽이라는 각각의 메시지 저장소에 데이터를 저장하면 `Subscriber`이 원하는 토픽에서 데이터를 가져가는 형태의 통신을 말한다.
* 비동기 메시지 전송 방식으로 발신자의 메시지에는 수신자가 정해져 있지 않은 상태로 발행된다. 구독을 신청한 수신자만이 정해진 메시지를 받을 수 있다. 또한 수신자는 발신자 정보가 없어도 원하는 메시지를 수신할 수 있습니다. 이러한 구조 덕분에 다이나믹한 네트워크 토폴로지와 높은 확장성을 확보 할 수 있습니다.



# 3. 카프카 브로커

* 카프카 브로커는 카프카 클라이언트와 데이터를 주고 받기위해 사용되는 주체이자 데이터를 분산 저장하여 장애가 발생하더라도 안전하게 사용할 수 있도록 도와주는 애플리케이션이다.

* 하나의 서버에는 한 개의 카프카 브로커 프로세스가 실행된다.
* 카프카 브로커 서버 1대로도 기본 기능이 실행되지만 데이터를 안전하게 보관하기 위해 최소 3대 이상의 브로커를 1개의 클러스터로 묶어서 운영한다.
* 카프카 클러스터로 묶인 브로커들은 프로듀서가 보낸 데이터를 안전하게 분산 저장하고 복제하는 역할을 한다.



## 3.1 데이터 저장 전송

* 프로듀서로부터 데이터를 전달 받으면 카프카 브로커는 프로듀서가 요청한 토픽의 파티션에 데이터 저장한다.
  * 데이터가 저장되는 곳은 파일 시스템이다.
* 컨슈머가 데이터를 요청하면 파티션에 저장된 데이터를 전달한다.



## 3.2 데이터 복제, 싱크

* 데이터 복제를 통해 카프카는 장애 허용 시스템으로 동작한다.
  * 장애 허용 시스템 -> 클러스터로 묶인 브로커 중 일부에 장애가 발생해도 데이터가 유실되지 않는다.
* 카프카의 데이터 복제는 파티션 단위로 이루어진다.
* 토픽 생성시 파티션의 복제 개수를 설정할 수 있다.
  * 최소 1, 최대 브로커의 개수만큼 설정 가능
* 복제된 파티션은 리더와 팔로워로 구성된다.
  * 리더 파티션: 프로듀서 또는 컨슈머와 직접 통신하는 파티션
  * 팔로워 파티션: 나머지 / 복제 데이터를 가지고있는 파티션
    * 리더 파티션의 오프셋을 확인하여 자신의 오프셋과 차이가 있는 경우 리더로부터 데이터를 가져온다. 이 과정을 복제(replication)이라 한다.



## 3.3 컨트롤러

* 클러스터 중 한 대의 브로커가 컨트롤러 역할을 한다.
* 컨트롤러는 다른 브로커들의 상태를 체크하고 브로커가 클러스터에서 빠지는 경우 해당 브로커에 존재하는 리더 파티션을 재분배한다.
* 컨트롤러 역할을 하는 브로커가 장애가 생기면 다른 브로커가 컨트롤러 역할을 한다.



## 3.4 데이터 삭제

* 컨슈머가 데이터를 가져가더라도 토픽의 데이터는 삭제되지 않는다.
* 컨슈머나, 프로듀서가 데이터 삭제를 요청할 수 없다.
* 브로커만이 데이터를 삭제할 수 있다.
* 데이터 삭제는 로그 세그먼트라는 파일 단위로 이루어지며 이 세그먼트에는 다수의 데이터가 들어있어 특정 데이터를 선별해서 삭제할 수 없다.



## 3.5 컨슈머 오프셋 저장

* 컨슈머 그룹은 토픽의 특정 파티션으로부터 데이터를 가져가서 처리하고 파티션의 어느 레코드까지 가져갔는지 확인을 위해 오프셋을 저장한다.
* 컨슈머 그룹은 저장된 오프셋을 확인하고 다음 레코드를 가져가서 처리한다.



## 3.6 코디네이터

* 클러스터 중 한 대의 브로커가 코디네이터의 역할을 한다.
* 코디네이터는 컨슈머 그룹의 상태를 체크하고 파티션을 컨슈머와 매칭되도록 분배하는 역할을 한다.
  * 컨슈머가 그룹에서 빠지면 매칭되지 않는 파티션을 정상 작동하는 컨슈머에게 할당한다.
  * 이렇게 파티션을 컨슈머로 재할당하는 과정을 리밸런스(rebalance)라고 한다.



# 4. 토픽(topic)

## 4.1 토픽의 개념

* `topic`이란 카프카에서 데이터를 구분하기 위해 사용하는 단위이다. 
* `topic`은 1개 이상의 `partition`을 소유하고 있다.

# 5. 파티션(partition)

## 5.1 파티션의 개념

* `partition`에는 `producer`가 보낸 데이터가 저장되어있다.
* 이 데이터를 `record`라고 부른다.
* 카프카는 이 `partition`을 통해 병렬처리를 제공한다.
  * 그룹으로 묶인 `consumer`들이 `record`를 병렬로 처리함
  *  `consumer`의 처리량이 한계치에 도달했다면  `consumer`의 개수를 늘리고 `partition`도 늘리면 처리량이 증가하는 효과를 볼 수 있다.



# 6.레코드(record)

* `record`는 타임스탬프, 메시지 키, 메시지 값, 오프셋으로 구성되어 있다.
* 메시지 키
  * 메시지 키는 메시지 값을 순서대로 처리하거나 메시지 값의 종류를 나타내기 위해 사용된다.
  * `producer`가 `topic`에 `record`를 전송할 때 메시지 키의 해시값을 토대로 `partition`을 지정한다.
  * 즉 동일한 메시지 값이라면 동일한 `partition` 에 들어간다.
  * 메시지 키를 사용하지 않으면 레코드는 프로듀서 기본 설정 파티셔너에 따라 `partition` 에 분배되어 적재된다.
* 메시지 값
  * 실질적으로 처리할 데이터가 들어가 있다.
  * 메시지 키와 메시지 값은 직렬화되어 브로커로 전송되기 때문에 컨슈머가 동일한 형태로 역직렬화를 수행해야한다.
* 타임스탬프
  * `producer`가 생성한 `record`가 `broker`로 전송되면 타임스탬프가 지정되어 저장된다.
  * 타임스탬프는 `broker` 기준 유닉스 시간이 설정된다.
* 오프셋
  * `producer`가 생성한 `record`가 `broker`로 전송되면 오프셋이 지정되어 저장된다.
  * `record` 의 오프셋은 0이상의 숫자로 이루어져 있다.
  * `record`  의 오프셋은 직접 지정할 수 없고 브로커에 저장될 때  `이전 전송된 레코드 오프셋 + 1` 값이 설정된다.
  * 오프셋은 `consumer` 가 데이터를 가져갈 때 사용한다. 
    * 오프셋을 이용해 그룹으로 이루어진 컨슈머들이 파티션의 데이터를 어디까지 가져갔는지 알 수 있다.
* `broker`에 한번 적재된 `record`는 수정할 수 없고 로그 리텐션 기간 또는 용량에 따라서만 삭제된다.

# 카프카 설치

[도커 이용](https://docs.confluent.io/platform/current/quickstart/ce-docker-quickstart.html?utm_medium=sem&utm_source=google&utm_campaign=ch.sem_br.nonbrand_tp.prs_tgt.kafka_mt.xct_rgn.apac_lng.eng_dv.all_con.kafka-docker&utm_term=kafka%20docker&creative=&device=c&placement=&gclid=CjwKCAjw_JuGBhBkEiwA1xmbRdJFuB00P5LIu4FxMJtIrT1Z-MsaHNp1HnRSXVFDBBA-cGlaWa1tDhoCLXoQAvD_BwE)

