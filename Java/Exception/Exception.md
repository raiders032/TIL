## Exception

* Exception 클래스를 상속한 예외들은 모두 checked 예외이다.
* checked 예외란 컴파일러가 예외 처리를 제대로 하는지 확인 해주는 예외이다.
* 어느 메서드가 어떤 예외를 던지는지 명확히 알 수 있다.
* 예외가 발생하는 코드에서 아래와 같은 조치중 하나를 하지않는다면 컴파일 오류가 발생한다.
  * 발생한 예외를 그 메서드 안에서 처리(catch 블록)
  * 처리를 안 할 경우 그 사실을 메서드 시그니쳐 옆에 표기(throws)
    * 그러면 이 메서드의 호출자가 다시 이 둘 중에 하나를 해야한다.



## RuntimeException

* RuntimeException 클래스를 상속한 예외는 모두 unchecked 예외이다
* unchecked 예외는 컴파일러가 체크를 하지 않기 때문에 개발자가 예외 처리를 해줘야한다.
* 처리를 안 할 경우에도 throws를 표기하지 않아도 된다.



## 비교

|                            | Checked Exception         | Unchecked Exception                            |
| -------------------------- | :------------------------ | ---------------------------------------------- |
| **처리 여부**              | 반드시 예외 처리 해야함   | 예외 처리 하지 않아도됨                        |
| 확인 시점                  | 컴파일                    | 런타임                                         |
| **트랜잭션 Rollback 여부** | Rollback 안됨             | Rollback 진행                                  |
| **대표 Exception**         | IOException, SQLException | NullPointerException, IllegalArgumentException |





## 둘 중 어떤 예외를 사용해야 될까?

* checked 예외로 만들었다는 것은 오류를 회복하라는 뜻이다. 즉 예외를 처리해서 정상상태로 만들라는 것이다.
* 회복을 하는것(예외로부터 안전한 프로그래밍)이 쉬울까?
  * 매우 어렵다 여러 연산 도중 예외가 발생했을 때 이미 처리된 연산을 되돌리기란 쉽지 않다.
  * 클래스의 수가 적은 간단한 구조에서는 가능해도 복잡할 수록 어려워진다.
  * 모든 곳에서는 불가능 필요한 곳에서만 하자!



## 예외를 얼마나 세분화해야 될까?

* 예전엔 checked 예외를 주로 사용해서 예외 타입에 따라 처리를 달리 해줘야 했기 때문에 예외를 세분화하는 경향이 있었다.
* 요즘은 catch을 할 때 Exception으로 모든 예외를 잡는 방식을 선호한다.
* 예외를 세분화하지말고 RuntimeException을 던지고 메세지를 잘 적자는 사람도 있고 예외를 던질 때는 세세한 예외 형을 던지자는 사람도 있다.
* 팀 동료들과 상의해서 결정을 해보자

