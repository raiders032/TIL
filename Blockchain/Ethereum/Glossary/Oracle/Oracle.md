# 1 Oracle

* 오라클은 **외부의 데이터를 이더리움 스마트 컨트랙트로 제공하는 시스템**이다
* 오라클은 **탈중앙화** 원칙을 바탕으로 작동하기 때문에 **신뢰가 필요 없는 시스템**이다.



# 2 Oracle이 필요한 이유

* EVM의 실행은 **결정론적**이고, 이더리움 상태와 **서명된 트랜잭션의 공유 컨텍스트**에 기반을 두고 있어야한다.



**EVM 및 컨트랙트에서 동작하는 임의성을 위한 소스가 없다.**

* 임의성을 가지는 소스가 있다면 서로 다른 노드다 동일한 컨텍스트에서 정확하게 동일한 코드를 실행해도 결과가 다르게 나온다
* 즉 동일한 원장을 공유해야 하는데, 서로 다른 원장을 가지고 있게 되는 것으로, 이는 곧 스마트 컨트랙트가 실행될 때마다 다른 결과 상태가 나올 수 있다는 가능성을 의미한다
* 여러 노드가 독립적으로 실행되는 네트워크에서 결과 상태가 무엇이지 합의가 불가능해진다.



**외부 데이터가 트랜잭션의 데이터 페이로드로서만 유입된다.**

* 모든 노드는 서명된 트랙잭션의 내용에는 동의한다.
* 외부 데이터를 트랜잭션의 데이터의 일부로 포함시키면 해결이 가능하다
* 그러나 데이터가 확인할 수 없는 출처에서 비롯되어 신뢰할 수 없다.
* 이러한 문제를 해결하기 위해 오라클을 사용한다.

# 3 Oracle 유스케이스와 사례

* 오라클은 이상적으로 컨트랙트를 위해 이더리움 플랫폼으로 축구 경기의 결과나 금 가격 혹은 순수 난수와 같은 외부 정보를 가지고 오는 데 신뢰가 필요 없는 방법을 제공한다.

> 예를 들어, 앨리스와 밥이 스포츠 경기의 결과에 내기를 하고 싶어한다고 가정해보자. 앨리스는 A팀에 20달러, 밥은 B팀에 20달러를 걸며 총 40달러는 스마트 계약에 의해 에스크로 보유된다. 게임이 끝났을 때, 컨트랙트는 앨리스에게 돈을 주어야할지 밥에게 주어야 할지 어떻게 알 수 있을까요? 정답은 정확한 매치 결과를 오프체인에서 가져와 안전하고 신뢰할 수 있는 방식으로 블록체인에 전달하는 오라클을 사용하는 것입니다.

* 하지안 외부 정보는 이더리움 보안 모델에 위험을 초해할 수 있다.
  * 보안의 취약점이 될 수 있다.
  * 스마트 유언: 컨트랙트에 의해서 제어되는 상속 금액이 많다면 소유자가 사망하기 전에 오라클을 해킹하고 자산을 분배



| 데이터 종류                                                  | 예시                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| 양자 및 열처리와 같은 물리적인 소스로부터 발생되는 난수 및 엔트로피 | 복권 스마트 계약에서 당첨자를 공정하게 뽑는 것               |
| 자연재해에 대한 파라미터 트리거                              | 지진 채권을 위한 리히터(Richiter) 규모 측정                  |
| 환율 데이터                                                  | 법정 화폐에 대한 암호화폐의 정확한 교환 비율                 |
| 자본 시장 데이터                                             | 토큰화된 자산 및 증권의 가격 책정                            |
| 벤치마크 참고 데이터                                         | 금리를 스마트 금융 파생 상품에 통합하는 것                   |
| 정적 및 유사 정적 데이터                                     | 증권 식별자, 국가 코드, 화폐 코드 등                         |
| 시간 및 간격 데이터                                          | 정확한 시간 측정에 근거한 이벤트 트리거                      |
| 날씨 데이터                                                  | 일기예보에 기초한 보험료 계산                                |
| 정치적 사건                                                  | 예측 시장 결과 제공                                          |
| 스포츠 이벤트                                                | 예측 시장 결과 제공 및 판타지 스포츠 계약                    |
| 지리적 위치 데이터                                           | 공급망 추적에 사용되는 데이터                                |
| 피해 확인                                                    | 보험 계약                                                    |
| 다른 블록체인에서발생하는 이벤트                             | 상호운용성 함수                                              |
| 이더 시장 가격                                               | 법정 화폐 기준 이더 가스 가격 오라클                         |
| 비행 통계                                                    | 항공편 티켓 풀링(pooling)에 사용된 그룹 또는 클럽의 통계[[1\]](http://wiki.hash.kr/index.php/오라클_(블록체인)#cite_note-.EB.AA.A8.EB.8F.84.EB.A6.AC-1) |



# 4 Oracle 디자인 패턴

## 4.1 **오라클 **핵심 기능

* 오프체인 소스에서 데이터를 수집한다
* 이러한 데이터를 서명된 메시지로 온체인에 전송한다
* 데이터를 컨트랙트 스토리지에서 저장햐여 사용할 수 있게 만든다
  * 오라클 컨트랙트의 retrieve함수 호출을 통해 다른 컨트랙트가 데이터 접근 가능
  * oracle’s storage를 직접 접근할 수도 있다.



## 4.2 오라클 설정

* 설정 방법은 immediate-read, publish-subscribe, request-response가 있다.



### 4.2.1 immediate-read

* 즉각적인 결정이 필요한 데이터를 제공
* 변경이 거의 없는 정보를 저장해 놓고 읽기만 하는 방식
* 트랜잭션 발행 없이 오라클 스토리지는 직접 조회가 가능 트랜잭션을 처리하는 가스 비용도 필요하지 않다
* 오라클에 저장된 데이터는 효율성이나 프라이버시 때문에 원시 데이터가 아닐 가능성이 높다
  * 학업성적 증명서의 경우 증명서의 해시만 저장하는 것으로 충분



**예시**

* 술을 사려는 고객의 나이를 확인하고 싶은 가게 -> 이 사람은 18세 이상인가?



**publish-subscribe**

* 변화가 예상되는 데이터를 브로드캐스팅하는 역할
* 자주 변경되는 데이터를 한 곳만 수정하고 필요한 사람들이 알아서 폴링하고 있다가 사용하는 방식
* 업데이트를 위해 온 체인 폴링 또는 오프 체인 데몬을 사용한다.
* 폴링은 웹 서버 세계에서는 매우 비효율적이지만, 블록체인 P2P 세계에서는 그렇지 않다. 
  * 오라클 업데이트를 위해서는 트랜잭션을 발생시키게 되고, 해당 트랜잭션이 블록에 포함되었다면 모든 노드들이 해당 내용을 자신의 노드에 기록하게 된다. 
  * 그러면 폴링을 서버를 폴링하는 것이 아니라 로컬을 폴링하는 것이다.

* 온 체인에서 폴링을 수행하게 되면 과도한 가스비가 발생할 수 있다.

**예시**

* 예 : 가격 정보, 기상 정보, 경제 또는 사회 통계, 교통 정보 등



**request-response**

* 데이터 공간이 너무 커서 스마트 컨트랙트에 저장할 수 없으며, 사용자는 한번에 전체 데이터 중 일부만 필요한 경우
* 실제로 오라클은 요청을 모니터링하고 데이터를 검색 및 반환하는데 사용되는 온체인 스마트 컨트랙트와 오프 체인 인프라 시스템으로 구현 될 수 있다.

1. dApp으로부터 쿼리를 받는다.
2. 쿼리를 파싱한다.
3. 비용이 지불되었는지, 데이터 액세스 권한이 있는지 확인한다.
4. 오프 체인 소스에서 관련 데이터를 검색한다. (필요한 경우 암호화)
5. 데이터가 포함 된 거래에 서명한다.
6. 트랜잭션을 네트워크로 브로드 캐스트한다.
7. 알림 등 필요한 추가 트랜잭션을 스케줄링한다.

# 5 데이터 인증

* 데이터 소스의 주체를 신뢰할 수 있다지만, 그 데이터를 온 체인으로 올리는 주체가 다른 경우 어떻게 믿어야 하는가?
* 전송 중에 데이터가 변조 될 수 있는 가능성이 있기 때문에, 변조되지 않았다는 무결성을 증명해야 한다.
* 증명하는 방식은 2가지로 볼 수 있다. 진위성 증명, 신뢰할 수 있는 실행 환경(TEE - Trusted Execution Environments)



## 5.1 진위성 증명

* 진위성 증명은 변조되지 않았다는 것을 암호학적으로 보장한다.
* Oraclize는 다양한 진위성 증명을 활용하는 오라클 서비스



## 5.2 신뢰할 수 있는 실행 환경(TEE)

- [Town Crier](http://www.town-crier.org/)는 데이터 무결성을 위해 하드웨어 기반의 보안 영역을 사용한다.



# 6 계산 오라클

- 오라클은 데이터의 요청 및 응답에만 사용되는 것 뿐만 아니라 계산 작업에도 사용할 수 있다.
  - 블록 가스 한도와 비교적 비싼 계산 비용을 고려하면 유용하다.
  - 온 체인에서 실행 불가능한 계산에 대한 입력을 받아 결과를 리턴한다.
- 예 : 계산 집약적인 회귀 계산을 수행하여 채권 계약의 수익률을 추정



**오라클라이즈**

* 오라클라이즈는 탈중앙화된 애플리케이션이 샌드박스형 [AWS](http://wiki.hash.kr/index.php/AWS) 가상머신에서 수행하는 계산 결과를 요청할 수 있는 서비스를 제공한다.
* 사용자가 구성한 도커파일(docker file)은 아카이브 형태로 분산형 파일 시스템([IPFS](http://wiki.hash.kr/index.php/IPFS))에 업로드되며, AWS 인스턴스는 이를 통해 실행 가능한 컨테이너를 만든다.
* 요청에 따라 오라클라이즈는 해시를 사용하여 이 아카이브를 검색한 다음, AWS에서 도커 컨테이너를 초기화 및 실행하고, 애플리케이션에 제공되는 모든 인수를 환경 변수로 전달한다. 
* 컨테이너화된 애플리케이션은 시간제한에 따라 계산을 수행하고 표준 출력에 결과를 기록한다.
* 그 출력 결과는 오라클라이즈로 검색하여 탈중앙화 애플리케이션에 반환할 수 있다.
* 오라클라이즈는 현재 감사 가능한 t2.micro AWS 인스턴스에서 이 서비스를 제공하고 있다. 
* 따라서 계산이 상당히 중요한 경우라면 지정된 정확한 도커 컨테이너가 실행되었는지 확인할 수 있다. 
* 그런데도 불구하고 이것은 진정한 탈중앙화 솔루션이 아니다.



**cryptlet**

* 마이크로소프트에서는 입증할 수 있는 오라클 신뢰를 위한 표준인 크립트렛(cryptlet) 개념이 좀 더 광범위한 ESC 프레임워크의 일부로 공식화되어 제공하고 있다.
* 크립트렛은 암호화된 캡슐 내에서 I/O 같은 인프라를 추상화하고, 크립토델리게이트(CryptoDelegate)가 첨부되어 송수신 메시지가 자동으로 서명, 유효성 검사, 검증되도록 실행된다. 
* 크립트렛은 분산 트랜잭션을 지원하므로 계약 논리는 복잡한 다단계, 다중 블록체인, 외부 시스템 트랜잭션을 ACID 방식으로 처리할 수 있다. 
* 이를 통해 개발자는 스마트 계약에서 사용하기 위해 오라클의 신뢰에 대한 포터블하고, 독립적이며, 프라이빗한 솔루션을 만들 수 있다. 
* 크립트렛은 다음의 샘플 코드를 따른다.

```
public class SampleContractCryptlet : Cryptlet
{
    public SampleContractCryptlet(Guid id, Guid bindingId, string name,
         string address, IContainerServices hostContainer, bool contract)
         : base(id, bindingId, name, address, hostContainer, contract)
{
         MessageApi = new CryptletMessageApi(GetType() .FullName,
              new SampleContractConstructor())
```



**TrueBit**

* 트루비트(TrueBit)는 보다 탈중앙화된 솔루션으로 확장성과 검증 가능한 오프체인 계산을 위한 솔루션을 제공한다. 
* 이것은 계산자와 검증자 시스템을 사용하는데, 계산의 수행과 검증에 대해 이들에게 보상을 각각 제공하다. 
* 만약 어떤 계산 결과에 대해 챌린지가 나오면, 계산의 하위 집합에 대한 반복적인 검증 프로세스가 온체인에서 수행되며, 이는 일종의 검증 게임(verification game)이 된다. 
* 게임은 일련의 라운드를 진행하며, 각각은 계산의 더 작은 하위 집합을 반복적으로 확인한다. 
* 결국 게임은 최종 라운드에 이르게 되는데, 챌린지가 온체인에서 수행될 만큼 충분히 작아졌으므로 심판관은 솔루션에 대한 챌린지가 맞았는지 최종 판결을 온체인에서 할 수 있다. 
* 사실상 트루비트는 컴퓨테이션 시장을 구현한 것인데, 이것은 탈중앙화된 애플리케이션들이 네트워크 밖에서 검증 가능한 컴퓨테이션을 살 수 있도록 해주되, 검증 게임의 룰은 이더리움에 의해 강제되도록 만들어준다. 
* 이론상으로는 신뢰가 필요 없는 스마트 계약을 통해 모든 계산 작업을 안전하게 수행할 수 있다.
* 트루비트 같은 시스템에는 머신러닝에서부터 작업증명(PoW) 검증에 이르기까지 다양한 애플리케이션이 있다. 
* 후자의 예로, 도지-이더리움 브리지는 도지코인(Dogecoin)의 작업증명을 검증하기 위해 트루비트를 사용하는데, 이는 이더리움 블록 가스 한도 내에서는 계산할 수 없는 메모리를 많이 사용하고 계산 집약적인 함수가 검증된다. 
* 트루비트를 이용한 검증 작업을 수행함으로써 이더리움의 린케비(Rinkeby) 테스트 네트워크에서 스마트 계약으로 도지코인 트랜잭션을 안전하게 확인할 수 있다.

# 7 탈중앙화 오라클

* 중앙화된 데이터 또는 컴퓨테이션 오라클은 이더리움 네트워크의 단일 실패 지점이 된다.
* 오라클이 부패하면 온체인에 전달되는 데이터가 매우 부정확할 수 있으며 스마트 계약이 매우 잘못된 결과를 실행할 수 있며 돌이킬 수 도 없다.
* 데이터 조작, 부정확성 및 다운타임을 방지하기 위한 분산형 오라클이 필요하다



**체인링크**

>  체인링크(ChainLink)는 평판(reputation) 계약, 오더매칭(order-matching) 계약, 그리고 집계(aggregation) 계약이라는 세 가지 주요 스마트 계약과 데이터 공급자의 오프체인 레지스트리로 구성된 탈중앙화 오라클 네트워크를 제안했다. 평판 계약은 데이터 제공자의 성과를 추적하는 데 사용된다. 평판 계약의 점수는 오라클로부터 입찰가를 선택한다. 그런 다음, 쿼리 파라미터와 필요한 오라클 수를 포함하는 서비스 수준 계약을 완료한다. 즉, 구매자는 개별 오라클과 직접 트랜잭션 할 필요가 없다. 집계 계약은 여러 오라클로부터 응답을 수집하고, 쿼리의 최종 집합 결과를 계산하고, 마침내 그 결과를 평판 계약으로 피드백해 준다.
>
> 이러한 탈중앙화된 방식의 주요 문제점 중 하나는 집계 함수의 공식화이다. 체인링크는 각 오라클 응답에 대해 유효성 점수가 보고되도록 가중치 응답을 계산하는 것을 제안하고 있는데, 이것은 각각의 응답에 대해 하나의 유효성 점수를 부여하는 것을 허용한다. 여기에서 유효하지 않은 점수를 식별하기는 쉽지 않은 문제인데, 왜냐하면 이것은 다른 피어들이 제공한 응답으로부터 차이가 많이 나는 값들은 부정확한 것으로 전제하는 것이기 때문이다. 유효성 점수를 응답 점수의 분포도상에서의 위치를 기준으로 계산하면, 평균을 벗어나는 값들에 대한 페널티를 받게 된다. 따라서 체인링크는 표준 집계 계약도 제공하지만, 사용자의 집계 계약도 지정할 수 있다.



**쉘링코인**

> 이와 관련된 아이디어로서 쉘링코인(Schelling Coin) 프로토콜이 있다. 여기서는 여러 참가자가 값을 보고하고 중간값을 올바른(correct) 대답으로 취한다. 리포터들은 보증금을 내고 참가해야만 하는데, 이 보증금은 중간값에 가장 가까운 값을 제시한 사람순으로 재분배되기 때문에 다른 사람들과 비슷한 값을 보고하도록 동기부여를 하게 된다. 쉘링포인트로도 알려진 이 공통 값(common value)은 응답자들이 협조해서 구해야 할 자연스럽고 명백한 값으로 간주할 것이고, 따라서 실제 값에 근접할 것으로 예상할 수 있다.



**TrueBit**

>  트루비트의 제이슨 토이치(Jason Teutsch)는 최근 탈중앙화형 오프체인 데이터 가용성 오라클을 위한 새로운 디자인을 제안했다. 이 디자인은 등록된 데이터가 특정 에포크 동안 사용 가능한지 여부를 정확하게 보고할 수 있는 전용 작업증명 블록체인을 활용한다. 채굴자는 현재 등록된 모든 데이터를 다운로드, 저장 및 전파하려고 시도하므로 데이터를 로컬에서 사용할 수 있다. 이런 시스템은 모든 채굴 노드가 등록된 모든 데이터를 저장하고 전파한다는 점에서 비싸지만, 등록 기간이 끝나면 데이터를 삭제해서 저장 공간을 재사용할 수 있게 한다.



# 8 솔리디티에서 오라클 클라이언트 인터페이스

* 오라클라이즈가 API에서 ETH/USD 가격을 지속적으로 폴링하고 결과를 저장하고 사용하는 솔리디티 예시

```solidity
pragma solidity ^0.4.1;
import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";
 
// Oraclize와 통합하려면 Oraclize를 상속 받는다.
contract EthUsdPriceTicker is usingOraclize {

		// 업데이트된 ETH/USD 가격을 저장소에 보관합니다.
    // 10분마다 업데이트됩니다.
    uint public ethUsd;

    event newOraclizeQuery(string description);
    event newCallbackResult(string result);

    function EthUsdPriceTicker() payable {
        // signals TLSN proof generation and storage on IPFS
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);

        // requests query
        queryTicker();
    }

    function __callback(bytes32 _queryId, string _result, bytes _proof) public {
        if (msg.sender != oraclize_cbAddress()) throw;
        newCallbackResult(_result);

        /*
         * Parse the result string into an unsigned integer for on-chain use.
         * Uses inherited "parseInt" helper from "usingOraclize", allowing for
         * a string result such as "123.45" to be converted to uint 12345.
         */
        ethUsd = parseInt(_result, 2);

        // called from callback since we're polling the price
        queryTicker();
    }

    function queryTicker() external payable {
        if (oraclize_getPrice("URL") > this.balance) {
            newOraclizeQuery("Oraclize query was NOT sent, please add some ETH
                to cover for the query fee");
        } else {
            newOraclizeQuery("Oraclize query was sent, standing by for the
                answer...");

            // query params are (delay in seconds, datasource type,
            // datasource argument)
            // specifies JSONPath, to fetch specific portion of JSON API result
            oraclize_query(60 * 10, "URL",
                "json(https://min-api.cryptocompare.com/data/price?\
                fsym=ETH&tsyms=USD,EUR,GBP).USD");
        }
    }
}
```