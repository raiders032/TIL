# 1 단위 테스트란 무엇인가?

* 단위 테스트의 정의에는 많은 미묘한 차이들이 있다
* 해석에 차이에 따라 고전파와 런던파로 두 가지로 나뉜다



## 1.1 단위 테스트 정의

* 단위 테스트에는 많은 정의가 있지만 중요한 것만 추리면 아래와 같다
  * **작은 코드 조각을 검증하고**
  * **빠르게 수행하고**
  * **격리된 방식으로 처리하는 자동화된 테스트다**
* 첫 번쨰 속성은 논란의 여지가 없다지만 정확히 빠르다는 것은 주관적인 척도이므로 논쟁이 있을 수 있지만 그리 중요하지 않다
  * 테스트 스위트의 실행 시간이 충분하다면 테스트가 충분히 빠르다는 의미다
* 대중의 의견이 갈리는 것은 세 번째 속성이다. 
  * 고전파와 런던파의 견해가 이 속성에서 갈린다



## 1.2 고전파와 런던파 

* 고전파는 모든 사람이 단위 테스트와 테스트 주도 개발에 원론적으로 접근하는 방식이기 때문에 고전이라고 한다
  * 고전파의 입장에서 가장 고전적인 책은 켄트 백이 지은 `테스트 주도 개발`일 것이다
* 런던 스타일은 때때로 목 추종자로 표현된다



## 1.3 고전파 테스트 예시

* 온라인 상점을 운영한다고 가정하고 상점에 재고가 충분하면 구매는 성공으로, 구매 수량만큼 제품 수량이 줄어든다
* 제품이 충분하지 않으면 구매는 성공하지 못하며 상점에는 아무 일도 일어나지 않는다
* 테스트는 고전적인 스타일로 작성됐으며 일반적인 3단 구성인 준비, 실행, 검증 패턴(AAA Pattern)을 사용한다



**AAA Pattern 고전파 테스트 코드**

* 준비(Arrange) 부분은 의존성과 테스트 대상 시스템 모두 준비하는 부분이다
  * 테스트 대상 시스템(System Under Test)인 SUT와 하나의 협력자를 준비한다
  * SUT: 고객(Customer)
  * 협력자: 상점(Store)
* 실행(Act) 부분은 customer.purchase() 검증하고자 하는 동작을 수행한다
* 검증(Assert) 부분은 동작이 예상 결과로 이어지는지 확인한다
* 아래 코드는 고전 스타일로 협력자를 대체하지 않고 운영용 인스턴스를 사용한다
  * 따라서 Customer와 Store를 둘 다 효과적으로 검증한다
  * 그러나 Customer가 올바르게 작동하더라도 Store 내부에 버그가 있다면 단위 테스트에 실패할 수 있다
  * 즉 테스트에서 SUT와 협력자가 서로 격리돼 있지 않기 때문에 발생하는 문제다

```java
@Test
void purchase_succeeds_when_enough_inventory(){
  // Arrange
  Store store = new Store();
  store.addInventory(Product.Shampoo, 10);
  Customer customer = new Customer();

  // Act
  boolean success = customer.purchase(store, Product.Shampoo, 5);

  // Assert
  Assertions.assertThat(success).isTrue();
  Assertions.assertThat(store.getInventory(Product.Shampoo)).isEqualTo(5);
}
```



## 1.4 런던파 테스트 예시

* 위에 테스트 코드를 런던파 스타일로 수정해보자
* 목과 스텁 간의 차이는 이후에 다시 다룬다 지금은 목이 테스트 대역에 부분집합이라는 것만 기억하자
* 사람들이 테스트 대역과 목을 동의어로 사용하지만 기술적으로 그렇지 않다



**AAA Pattern 런던파 테스트 코드**

* 준비 단계에서 테스트는 Store의 실제 인스턴스를 생성하지 않고 Mock 객체를 대신 사용한다
  * 샴푸 재고를 추가해 Stroe의 상태를 수정하는 대신 hasEnoughInventory() 메서드를 호출에 어떻게 응답하는지 목에 직접 정의한다
* 검증 단계에서는 이전과 같이 Customer의 purchase 호출 결과를 확인하지만 방법이 다르다
  * 이전에는 Stroe의 상태를 검증했다
  * 지금은 Customer와 Stroe 간의 상호 작용을 검사한다
  * 즉 Customer가 Stroe를 올바르게 호출했는지 검증한다

```java
@Test
void purchase_succeeds_when_enough_inventory_mock() {
  // Arrange
  Store storeMock = mock(Store.class);
  given(storeMock.hasEnoughInventory(Product.Shampoo, 5))
    .willReturn(true);
  Customer customer = new Customer();

  // Act
  boolean success = customer.purchase(storeMock, Product.Shampoo, 5);

  // Assert
  assertThat(success).isTrue();
  assertThat(storeMock.getInventory(Product.Shampoo)).isEqualTo(5);
  verify(storeMock, times(1)).hasEnoughInventory(Product.Shampoo, 5);
}
```



# 2 런던파의 단위 테스트



## 2.1 격리 문제에 대한 런던파 접근

* 코드 조각을 격리된 방식으로 검증한다는 것은 무엇을 의마할까?
* 런던파는 테스트 대상 시스템을 협력자에게서 격리하는 것을 일컫는다
* **즉 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역으로 대체해야 한다**
  * [Test-Double.md](../Test-Double/Test-Double.md) 참고
* 이렇게 동작을 외부 영향과 분리해서 테스트 대상 클래스에만 집중할 수 있다



## 2.2 런던파 접근의 장점

**테스트가 실패하면 코드베이스의 어느 부분이 고장 났는지 확실히 알 수 있다**

* 테스트 대상 시스템이 고장난 것
* 대상 클래스의 모든 의존성은 테스트 대역으로 대체됐기 때문에 의심할 여지가 없다

**객체 그래프를 분할할 수 있어 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다**

* 객체 그래프: 같은 문제를 해결하는 클래의 통신망
* 모든 클래스가 각각의 직접적인 의존성을 갖고 있으면 그 의존성이 또 다른 의존성을 갖고 있는 식으로 그래프가 상당히 복잡해진다
* 심지어 순환 의존성이 있을 수 있다
* 의존성을 가진 코드베이스를 테스트하는 것은 테스트 대역 없이는 어렵다
* 테스트 대역을 사용하면 객체 그래프를 다시 만들지 않아도 된다

**간단한 테스트 스위트 구조**

* 프로젝트 전반적으로 한 번에 한 클래스만 테스트하라는 지침을 도입하면 전체 단위 테스트 스위트를 간단한 구조로 할 수 있다
* 더 이상 코드베이스를 테스트하는 방법을 고민할 필요가 없다
* 클래스가 있다면 클래스에 해당하는 단위 테스트 클래스를 생성하면 된다



## 2.3 런던파 접근의 단점

**과도한 명세 문제**

* 런던 스타일이 고전 스타일 테스트보다 테스트가 구현에 더 자주 결합되는 편이다
* 테스트는 단일 동작 단위를 검증해야 한다
  * 이보다 작은 단위로 검증하게 되면 이 테스트가 무엇을 검증하는지 정확히 이해하기가 어려워 진다
* 단인 동작 단위를 더 작은 단위로 검증하는 것의 차이는 비유하자면 `우리집 강아지를 부르면, 바로 나에게 온다` 와 `우리집 강아지를 부르면 먼저 왼쪽 앞다리를 움직이고, 이어서 오른쪽 앞다리를 움직이고, 머리를 돌리고, 꼬리를 흔들기 시작한다` 의 차이와 같다
* 실제 동작(개가 주인에게 오는 것) 대신 개별 클래스(다리, 머리, 꼬리)를 목표로 테스트하면 실제 동작을 테스트 하는 건지 이해하기 힘들다
  * 개별 클래스를 목표로 테스트 하면 강아지가 나에게 오고 있는가? 아니면 도망을 가고 있는가? 알 수 없는 테스트가 된다

# 3 고전파의 단위 테스트

## 3.1 격리 문제에 대한 고전파 접근

* 런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 보는 반면, 고전파는 단위 테스트끼리 격리하는 것으로 본다
* 단위 테스트의 속성
  * **작은 코드 조각을 검증하고**
  * **빠르게 수행하고**
  * **격리된 방식으로 처리하는 자동화된 테스트다**
* `작은 코드 조각을 검증하고` 작은 코드 조각은 얼마나 작아야 할까? 고전파의 테스트 단위를 알아보자
* 고전파는 코드를 꼭 격리하는 방식으로 테스트하지 않고 대신 **단위 테스트를 서로 격리해서 실행한다**
  * **즉 고전파의 격리 단위는 단위 테스트이다**
  * 단위가 반드시 클래스에 국한될 필요는 없고 공유 의존성이 없는 한 여러 클래스를 묶어서 단위 테스트할 수도 있다
* 단위 테스트를 격리하면 테스트를 어떤 순서(병렬이나 순차 등)로든 가장 적합한 방식으로 실행할 수 있고 서로의 결과에 영향을 미치지 않는다
  * 여러 클래스가 모두 메모리에 상주하고 **공유 상태**에 도달하지 않는 한,  여러 클래스를 한번에 테스트해도 괜찮다
* 단위 테스트간 격리를 의해 공유 의존성은 대체되어야 한다
* 공유 의존성을 대체하는 또 다른 이유는 테스트 실행 속도를 높이는 데 있다
  * 공유 의존성은 거의 항상 실행 프로세스 외부에 있는데 대표적으로 데이터베이스나 파일 시스템에 대한 호출은 비공개 의존성보다 오래 걸린다
  * 단위 테스트의 두 번째 속성 `빠르게 수행하고` 을 만족할 필요성이 있으므로 공유 의존성을 가진 테스트는 단위 테스트 영역에서 통합 테스트 영역으로 넘어간다

**공유 상태**

* 데이터베이스, 파일 시스템 등 프로세스 외부 의존성이 공유 상태의 대표적인 예다
* 예를 들어 어떤 테스트가 준비 단계에서 데이터베이스에 고객을 생성할 수 있고, 이 테스트가 실행되기 전에 다른 테스트의 준비 단계에서 고객을 삭제할 수 있다 이 두가지 테스트를 병렬로 실행하면 첫 번째 테스트가 실패하는데 이는 제품 코드의 문제가 아니라 두 번째 테스트의 간섭 떄문이다

**공유 의존성**

* **공유 의존성은 테스트간에 공유되고 서로의 결과에 영향을 미칠수 있는 수단을 제공하는 의존성이다**
* 공유 의존성의 전형적인 예는 정적 가변 필드이다
  * 필드의 변경 사항은 동일한 프로세스 내에서 실행되는 모든 단위 테스트에서 볼 수 있기 때문
* 데이터베이스도 공유 의존선의 전형적인 예

**비공개 의존성**

* 비공개 의존성은 공유되지 않은 의존성이다
* 프로세스 외부 의존성은 애플리케이션 실행 프로세스 외부에서 실행되는 의존성이며 아직 메모리에 없는 데이터에 대한 프록시다
* 프로세스 외부 의존성은 대부분 공유 의존성이지만 모두 그런것은 아니다
* 데이터베이스는 프로세스 외부이면 공유 의존성이나 각 테스트 실행전에 도커 컨테이너로 데이터베이스를 시작하면테스트가 더 이상 동일한 인스턴스로 작동하지 않기 때문에 프로세스 외부이면서 공유하지 않는 비공개 의존성이 된다

**고전파 관점에서 다시 정의한 단위 테스트**

* **단일 동작 단위를 검증하고**
* **빠르게 수행하고**
* **다른 테스트와 별도로 처리한다**



## 3.2 고전파 접근의 장점



## 3.3 고전파 접근의 단점

**테스트 대상 시스템을 설정하려면 (공유 의존성은 제외하고)전체 객체 그래프를 다시 생성해야 하는데 작업이 많을 수 있다**

* 하지만 크고 복잡한 그래프를 테스트할 방법을 찾는 대신 먼저 이러한 클래스 그래프를 갖지 않는데 집중해야 한다
* 대게 클래스 그래프가 커진 것은 코드 설계 문제의 결과다

**하나의 버그가 전체 시스템에 걸쳐 테스트를 실패하게 한다**

* 런던파 스타일의 테스트가 있는 시스템이 버그가 생기면 보통 SUT에 버그가 포함된 테스트만 실패한다
* 고전파에서는 오작동 하는 클래스를 참조하는 클라이언트를 대상으로 하는 테스트도 실패할 수 있다
* 마지막으로 한 수정이 무엇인지 알기 때문에 문제를 찾는 것이 그리 어렵지 않다 따라서 큰 단점은 아니다

# 4 런던파 고전파 비교



## 4.1 단위 테스트

* 런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 보는 반면, 고전파는 단위 테스트끼리 격리하는 것으로 본다

|        | 격리 주체   | 단위의 크기                  | 테스트 대역 사용 대상      |
| ------ | ----------- | ---------------------------- | -------------------------- |
| 런던파 | 단위        | 단일 클래스                  | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성                |



## 4.2 의존성을 다루는 법

* 두 학파가 의존성을 어떻게 대체하는지 알아보자



**런던파**

* 절대 변하지 않는 객체, 즉 불변 객체는 교체하지 않아도 된다
  * 런던파 테스트 예시에서 Product 인스턴스와 숫자 `5` 가 여기에 해당된다
  * 따라서 목을 만들지 않고 실제 객체를 사용했다
  * 이러한 불변 객체를 값 객체 또는 값이라고 하는데 주요 특징으로 정체성이 없다는 것이다
  * 그 결과, 두 객체가 동일한 내용을 갖고 있다면 어떤 객체를 사용하든 상관없다
* 불변 의존성을 제외한 모든 의존성을 교체한다
  * 공유 의존성을 교체한다
  * 변경이 가능한 비공개 의존성(예시에서 Store에 해당된다)을 교체한다

**고전파**

* 공유 의존성만 테스트 대역으로 교체한다
* 변경이 가능한 비공개 의존성(예시에서 Store에 해당된다)을 교체하지 않는다
* 변하지 않는 불변 의존성(Product 인스턴스와 숫자 `5`)도 당연히 교체하지 않는다

