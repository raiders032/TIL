## Account

* 이더리움에서 state는 `account`라고 불리는 객체로 구성된다
* account는 20바이트 주소를 가진다
  * Keccak-256을 사용하여 공개키의 해시를 계산 마지막 20바이트가 주소가된다.
* state 전환은 account 간의 직접적인 value 및 information 전송으로 이루어진다.



### **Account Fields**

* account의 state는 4가지의 필드로 구성된다.
* nonce
  * 각 트랜잭션이 한 번만 처리될 수 있도록 하기 위해 사용되는 카운터
  * `이 주소에서 보낸 트랜잭션의 수` 또는 (계정이 contract account인 경우) `이 계정으로 만든 [contract](#contract) 생성 수`
* balance
  * 이 주소에 의해 소유된 Wei의 수
* codeHash
  * 이 계정의 EVM 코드 해시
  * 주소가 메시지 수신할 경우 실행되는 코드입니다.
  * 코드는 불변하므로 다른 필드와 달리 생성 후에 바뀌지 않는다.
  * 이러한 모든 코드 조각은 나중에 검색할 수 있도록 해당 해시의 상태 데이터베이스에 포함되어 있습니다.
* storageRoot
  * 계정의 storage 내용을 인코딩하는 Merkle Patricia 트리의 루트 노드에 대한 256비트 해시



### EOA

* Externally Owned Accounts
* 비밀키에 의해 통제되는 계정
* code를 가지고 있지 않다
* 트랜잭션을 만들고 서명함으로써 메시지를 전송할 수 있다.



### **Contract Accounts**

* contract code에 의해 통제되는 계정
  * 여기서 code란 컨트랙트 계정 생성시 이더리움 블록체인에 기록되고 EVM에 의해 실행되는 소프트웨어 프로그램이다.
* 메시지를 받을 때 마다 code가 작동한다
* storage를 읽고 쓸 수 있다
* 메시지를 보내거나 [컨트랙트](#contract)를 만들 수 있다.
* 컨트랙트 계정에는 개인키가 없다
  * 트랜잭션을 시작할 수 없다(컨트랙트의 발신자가 될 수 없다)
  * EOA만 트랜잭션을 시작할 수 있다.



## Block

* 비트코인의 블록과 유사하지만 차이점이 있다.
  * 주요 차이점으로는 비트코인과는 달리 이더리움 블록은 트랜잭션 리스트와 가장 최근의 상태(state) 복사본을 가지고 있다는 것이다. 
* 블록 구성요소
  * transaction 리스트
  * 최신 state
  * 블록 넘버
  * difficulty



### Bolck Headers

* parentHash 
  * 부모 블록 헤더의 해시(The Keccak 256-bit hash)
* ommersHash
* beneficiary
  * 160비트 주소
  * 채굴 승자에게 주어지는 수수료의 합을 이 주소로 전송한다.
* stateRoot
  * 모든 트랜잭션이 실행되고 종료된 후 상태 트리의 루트 노드의 해시(The Keccak 256-bit hash)
* transactionsRoot
  * The Keccak 256-bit hash of the root node of the trie structure populated with each transaction in the transactions list portion of the block
  * 트랜잭션으로 채워진 트리 구조의 루트 노드의 Keccak 256비트 해시
* receiptsRoot
* logsBloom
* difficulty
  * 블록의 난이도
  * 블록의 난이도는 이전 블록의 난이도와 타임스탬프로 계산된다.
* number
  * 부모 블록의 수
  * 제네시스 블록은 number가 0
* gaslimit
  * 블록당 소비할 수 있는 최대 가스 양
* gasUsed
  * 블록의 트랜잭션들에서 사용된 가스의 총 양
* timestamp
  * 블록 생성시 시간
* extraData
* mixHash
* nonce



### Block Validation Algorithm

* 기본적인 이더리움 블록 검증 알고리즘은 다음과 같다.

![ethereum-apply-block-diagram](https://ethereum.org/static/479308517ae57f0198f0a43f893884c3/89557/ethereum-apply-block-diagram.png)

1. 이전 참조되는 블록이 존재하고 유효한지 검사
2. 해당 블록의 타임스탬프가 이전 블록의 타임스탬프보다 크고 현 시점을 기준으로 15 분 후보다 작은 값인지 확인한다.
3. 해당 블록의 블록 넘버, difficulty, 트랜잭션 루트, 언클 루트, gas limit이 유효한지 검사
4. 해당 블록의 POW가 유효한지 검사
5. S[0]를 이전 블록의 마지막 상태라고 하자
6. TX를 블록에 포함될 transaction N개의 리스트라고 하자
   * 모든 i 에 대해서 `S[i+1] = APPLY(S[i],TX[i])` 라고 설정
   * 블록에서 소비된 총 가스가 GASLIMIT를 초과할 경우 오류를 반환한다.
7. 채굴자에게 지불된 보상 블록을 S[n] 덧붙인 후 이것을 S_FINAL 이라 하자.
8. 상태 S_FINAL 의 머클 트리 루트가 블록 헤더가 가지고 있는 최종 상태 루트와 같은지를 검증한다. 
   * 이 값이 같으면 그 블록은 유효한 블록이며, 다르면 유효하지 않은 것으로 판단한다.



**Block과 State**

* 모든 상태를 각 블록에 저장하는 것은 매우 비효율적인 것처럼 보이지만, 실제로는 효율성의 측면에서는 비트코인과 비교할만 하다. 
* 그 이유로는 상태가 트리 구조로 저장되고, 모든 블록 후에 단지 트리의 작은 부분만이 변경되기 때문이다. 
* 보통, 인접한 두개의 블록간에는 트리의 대부분의 내용이 같고, 따라서 한번 데이터가 저장되면 포인터(서브트리의 해쉬)를 사용하여 참조될 수 있다.
* 패트리시아 트리(Patricia tree)로 알려진 이러한 종류의 특별한 트리는 머클 트리 개념을 수정하여 노드를 단지 수정할 뿐만 아니라, 효율적으로 삽입되거나 삭제하여 이러한 작업을 수행할 수 있도록 해준다. 
* 모든 상태 정보가 마지막 블록에 포함되어 있기 때문에, 전체 블록체인 히스토리를 모두 저장할 필요가 없어지게 된다. 
* 이 방법을 비트코인에 적용한다면 5 - 20 배의 저장 공간 절약의 효과가 생길 것이다.



## Consensus Algorithm

* 합의 알고리즘이란 피투피 네트워크와 같이 정보 도달에 시간차가 있는 네트워크에서 여러 참가자들이 하나의 단일한 결과에 대한 합의를 얻기 위한 알고리즘이다.
* 블록체인 시스템의 경우 네트워크에 참여하는 모든 참여자들이 동일한 데이터를 복사하여 분산 저장하기 때문에 원본과 사본의 구별이 없으며, 통일된 의사결정을 내릴 수 있는 권위 있는 중앙(center)이 존재하지 않는다. 
  * 이런 상황에서 합리적이고 효율적인 의사결정을 내릴 수 있는 다양한 알고리즘이 개발되었다.



## Contract

* 컨트랙트는, 수행되거나 컴파일 되어야 할 어떤 것이라기 보다는이더리움의 실행 환경안에 살아있는 일종의 자율 에이전트이다
* 컨트랙트는 자신이 소유한 ether balance와 key/valuce store 대한 직접적인 통제권을 가지고 있다.



**Contract의 생성**

* 컨트랙트는 블록체인에 바이트코드를 등록하는 특별한 트랜잭션에 의해 생성된다.
* 컨트랙트가 생성되면 지갑과 마찬가지로 주소를 가지게된다.



**Contract의 실행**

* 컨트랙트는 메시지나 [트랜잭션](#transaction)을 트리거로 항상 특정 코드를 실행하는 자동화된 에이전트이다
* 트랜잭션의 목적지가 컨트랙트 주소일 때 트랜잭션과 트랜잭션 데이터를 입력으로 사용하여 컨트랙트가 EVM에서 실행된다.
* 트랜잭션에는 이더, 데이터가 포함된다
  * 이더가 포함되어 있으면 컨트랙트 잔액에 예치된다.
  * 데이터가 포함되어 있으면 데이터에서는 컨트랙트에서 명명된 함수를 지정하고 호출하여 함수에 인수를 전달할 수 있다
* 이렇게 트랜잭션은 컨트랙트 내의 함수를 호출할 수 있다.



## Code Execution

* 이더리움 Contract의 코드는 "이더리움 가상 머신 코드" 또는 "EVM 코드"라고 하는 저수준의 스택 기반 바이트코드 언어로 작성된다. 
* 이 코드는 연속된 바이트로 구성되어 있고, 각각의 바이트는 연산(operation)을 나타낸다. 
* 일반적으로 코드 실행은 코드 끝에 도달하거나 오류 또는 STOP 또는 RETURN 명령이 감지될 때까지 현재 프로그램 카운터(0에서 시작)에서 작업을 반복적으로 수행한 다음 프로그램 카운터를 하나씩 증가시키는 무한 루프이다. 
* operation은 데이터를 저장할 수 있는 세 가지 유형의 공간에 액세스할 수 있습니다.
  * 스택: 값을 넣고 뺄 수 있는 선입선출 저장소
  * 메모리: 무한 확장 가능한 바이트 배열
  * 스토리지: 계약의 장기 보관, 키/밸류 스토어. 연산이 끝나면 리셋되는 스택이나 메모리와 달리 스토리지는 장기간 지속된다.
* 코드는 또한 블록 헤더 데이터뿐만 아니라 특정 값이나, 발송자 및 수신되는 메시지의 데이터에 접근할 수 있고, 결과값으로 데이터의 바이트 배열을 반환할 수도 있다.
* 물리적인 하드웨어 관점에서 볼 때, 컨트랙트 코드는 “어디에서" 실행되는가?
  * 트랜잭션이 블록 B 에 포함되면 그 트랜잭션에 의해 발생할 코드의 실행은 현재 또는 향후에 블록 B 를 다운로드 하고 검증하는 모든 노드들에 의해 실행될 것이다



## Dapp

* Dapp은 공개되고 탈중앙화된 피어투피어 기반 서비스 위에 제공되는 웹 애플리케이션



**Dapp의 구성 요소**

* 최소 구성 요소
  * 블록체인 스마트 컨트랙트
  * 웹 프론트엔드 사용자 인터페이스
* 추가 요소 
  * 탈중앙화 스토리지 프로토콜과 플랫폼
  * 탈장앙화 메시지 프로토콜과 플랫폼



## Ether

* 이더리움(Ethereum) 네트워크는 그 안에서 자체적으로 통용되는, ‘이더(Ether)’라는 화폐를 가지고 있다. 
* 이더는 여러가지 가상자산들간의 효율적인 교환을 가능하게 하는 매개물의 역할을 하며, 또한 트랜잭션 수수료를 지불하기 위한 방법을 제공한다.



**Ether와 Gas**

* 이더리움 월드 컴퓨터에서 계산 비용을 지급하기 위한 가스를 이더로만 살 수 있다.
* 이더는 트랜잭션과함께 보내야하고 가스 구매를 위한 허용 가능한 가격을 명시적으로 지정한다.
* 가스의 가격은 정해져있지 않다.
* 트랜잭션을 위해 가스가 구매되고, 계산을 수행하고, 사용 후 남은 가스는 발신자에게 반환된다.



## Ethash

* 이더리움은 이더해시(Ethash)라는 작업증명 알고리즘을 사용하여 채굴할 수 있다.
* 이더리움은 비트코인과 같은 작업증명(PoW) 방식의 합의 알고리즘을 사용하고 있고 있지만, 기존 비트코인의 SHA-256 방식을 사용하지 않고, Hashimoto/Dagger hybrid인 이더해시(Ethash) 방식을 사용한다.
* 기존의 작업증명(PoW) 방식에서는 중국의 비트메인 등 소수의 채굴업체들이 에이식(ASIC) 방식의 고성능 채굴기를 제작하고 거대한 마이닝풀을 구성하여 막강한 영향력을 행사할 수 있다.
  * 심지어 전체 해시파워의 과반수에 이르는 연산력을 보유하고, 이른바 51% 공격도 가능한 상황이었다.
* 이더리움이 채택한 이더해시 방식을 따를 경우, 에이식(ASIC) 채굴기를 사용한 채굴이 매우 어렵다. 
  * 이더리움을 채굴하려면, 채굴하기 전에 컴퓨터에서 대그(DAG) 작성이라는 프로세스를 수행해야 한다. 



## EVM

* 이더리움 가상 머신이라고 하는 에뮬레이트된 컴퓨터에서 스마트 컨트랙트라는 프로그램을 실행한다.
* EVM은 싱글톤으로 전 세계에 걸친 단일 인스턴스 컴퓨터인 것처럼 작동한다.
* 각 노드들은 컨트랙트 실행을 확인하기 위해 EVM의 로컬 사본을 실행하고 이더리움 블록체인은 트랜잭션과 스마트 컨트랙트를 처리할 때 월드 컴퓨터의 변화하는 상태를 기록한다.



## Gas

* 계산의 기본 단위
* 보통, operation은 1개의 가스가 들어간다.
* 일부 operation은 계산 비용이 더 많이 들 수 있다.
* state의 일부로 저장되어야 하는 데이터의 양이 증가하면 더 많은 양의 가스가 든다. 
* 거래 데이터의 1바이트당 5가스의 수수료가 발생한다. 
* 수수료 시스템의 의도는 어떤 공격자가 계산, 밴드위스, 저장소 등을 포함하여 그들이 소비하는 모든 리소스에 비례하여 강제로 수수료를 지불하게 하는데 있다
* 이더를 거래할 때도 수수료가 요구된다. 이는 실물처럼 그냥 주고받는 것이 아니라 데이터를 옮기는 것이기 때문에 계산이 필요하고 여기서 계산을 위한 노동의 보상으로 발생하는 것이 가스다.
* 데이터를 옮기기 위해서는 채굴자들의 연산 작업이 필요한데, 채굴자들이 한 계산에 대한 보상으로 가스를 제공한다.
* 가스는 네트워크의 과부하를 막으며, 이더리움 플랫폼이 계속 운영되도록 하는 인센티브 역할을 한다



### Gas Price

* 가스 가격은 이더의 하위 단위인 기가웨이(Gwei)로 계산된다.
* 트랜잭션 생성자는 원하는 가스 가격을 지정할 수 있다.
  * 예를 들어 ‘가스 당 3Gwei를 지불할 용의가 있다.’라고 설정했을 때, 트랜잭션이 1,000,000가스를 소비하고 가스 가격을 3Gwei로 설정하면 해당 트랜잭션에 대한 수수료로 3,000,000Gwei를 지불하게 된다.
* 대부분의 채굴자들은 가스 가격의 내림차순으로 트랜잭션을 분류하고 가스 가격이 높은 트랜잭션을 선택하여 블록에 포함시키기 때문에 설정한 가스 가격이 높을수록 트랜잭션은 더 빨리 처리된다.
* 가격을 낮게 책정해도 결국 트랜잭션이 블록에 포함되기는 하지만 그 대기 시간이 상당히 길어질 가능성도 있다.
* 가스 가격은 일반 사람들에 의하여 무작위로 책정되지는 않고 가스 가격을 측정해주는 사이트가 있다. 이더리움 가스스테이션이라는 사이트인데, 이곳에서 적당한 가스 가격을 선택할 수 있다. 사용되는 가스의 평균값이라고 보면 된다. 빠른 처리를 원할 경우 여기 나온 금액보다 높은 가격을 측정하면 된다.



### Gas Limit

* 가스 한도는 작업 중단 시점을 보장함으로써 무제한으로 이더를 사용하는 것을 방지할 수 있다.
* 사용자는 트랜잭션을 실행하기 위해 사용할 가스의 최대 금액을 나타내는 가스 한도(Gas Limit)를 설정한다.
* 가스 한도는 요청하는 작업량의 추측이다. 하지만 추측은 쉬운 일이 아니다.
  * 일반적으로 21,000가스의 한도는 대부분의 거래를 만족한다고 알려져 있다.
* 한도가 낮으면 작업이 완료되지 않고 거래는 실패하며 그 시점까지 사용된 이더가 손실된다.
* 한도를 너무 높게 설정하여 한도 전에 작업이 끝나더라도 작업에 사용되지 않은 모든 이더는 다시 되돌려 받을 수 있다



**Gas Limit 측정**

* 트랜잭션은 크게 2가지 종류로 단순한 이더리움 송금(transactions)과 Contract를 실행시키는 트랜잭션(contract internal transactions)이 있다. 
* 이더리움 송금은 210000 Gas가 기본으로 100% 사용률이 가능하다
* Contract 실행은 코드의 복잡성에 따라 천차만별이다. 
  * 어떻게 이걸 예측해서 Gas Limit을 결정할 수 있을까? 
  * 답은 간단하게도 실제로 계산을 해보는 것이다. 
  * 명령어별로 이미 Gas Fee는 공개가 되어있으며 개발자는 자신의 Solidity 코드가 어느 정도의 Gas가 들지 예측할 수 있다.



## Message

* [컨트랙트](#contract)는 다른 컨트랙트으로 메시지를 보낼 수 있다. 
* message는 직렬화되지 않고 이더리움 실행 환경에만 존재하는 가상 객체입니다.



**Message 구성요소**

* 메시지 발신인
* 메시지 수신인
* ether 양
* Data(데이터)
* STARTGAS



**Transaction과 비교**

* 본질적으로 메시지는 외부 행위자가 아닌 계약에 의해 생산된다는 점을 제외하면 트랜잭션과 유사하다. 
* 컨트랜트가 `CALL` opcode를 실행할 때 메시지가 생성된다.
* 트랜잭션과 마찬가지로 메시지는 수신자 계정으로 코드를 실행되게한다. 
* 그러므로 계약들은 외부 행위자들이 할 수 있는 것과 정확히 같은 방식으로 다른 계약들과 관계를 맺을 수 있다.



## PoW

* 작업증명(PoW, Proof of Work)이란 목표값 이하의 해시를 찾는 과정을 무수히 반복함으로써 해당 작업에 참여했음을 증명하는 방식의 합의 알고리즘이다.



## PoS

* 지분증명(Proof of Stake)
* 지분증명이란 해당 암호화폐를 보유하고 있는 지분율에 비례하여 의사결정 권한을 주는 합의 알고리즘이다.
  * 해당 암호화폐를 보유한 지분에 따라 채굴에 성공할 확률이 결정된다.
* 채굴 과정이 필요 없다
* 지분증명은 작업증명(PoW)의 문제점으로 거론되는 막대한 에너지 및 리소스 소모를 해결한다.
* 별도의 채굴기가 필요 없이 코인을 보유하고 있으면 기본적인 자격이 충족된다.
* 지분증명은 완벽한 자본주의가 반영된 증명방식으로써 자신이 가진 코인 지분에 따라 영향력을 행사하게 된다.

**장점**

* 지분증명방식의 가장 많이 알려진 장점은 작업증명방식과 대조적으로 에너지 소모가 큰 프로세스가 없다는 점이다.
* 작업증명방식의 문제점 중 하나가 마이너들과 암호화폐 보유자들의 이해관계가 일치하지 않을 수도 있다는 점이다. 또한 다른 문제점은 장기적 관점에서 해시레이트(hashrate)를 리스(lease) 할 수 있다는 점이다. 지분증명방식은 이와 다르게 합의 대리인을 직접적으로 암호화폐에 투자하게 만들고 그에 따라 투자자와 합의 대리인의 이해관계가 같아지게 된다.
* 지분증명방식 기반 시스템의 또 다른 주요 장점은 작업증명방식의 마이닝이 가진 중앙집중식 특징으로 제거한다. 그로 인해 잠재적으로 더욱 탈중앙화 될 가능성이 있다는 것이다.

**단점**

* 지분증명방식 시스템은 체인 선택에 대한 해결책만을 제시했다. 그 외 나머지 문제점들에 대한 해답은 제시하지 못하였다.
* 이 시스템은 암호화폐 보유량에 비례하여 신규 자금을 배당한다. 그말은 소수의 사람들에게 자금이 집중될 수 있다는 것을 의미한다. 이러한 점을 보고 보상 시스템이 쓸모없고 인센티브를 전혀 제공하지 못하다고 비춰질 수 있다.
* 지분증명방식은 지분을 받기 위해서는 인터넷에 연결된 시스템에 의해 검증된 메시지가 필요하다. 결국 지분 보유자들은 해커에 의한 자금 도난 위험이 높은 핫 월렛을 갖고 있어야 한다. 프라이빗 키를 부여하여 단점을 보완하려고 했지만 그것은 완전한 해결책이 되지 못한다.
* 코인을 얻기위해 코인을 사용하지 않고 보유하려는 성향 때문에 코인의 유통성이 저하된다.



## Private key

* 계정 주소는 Private key에서 파생된다.
  * 공개키는 개인키에서 파생된다.
  * 외부 소유 계정의 이더리움 주소는 공개키-개인키 쌍의 공개키 부분에서 생성된다.
* 공개키는 은행 계좌번호와 개인키는 PIN(개인 식별 번호)와 유사하다
* 개인키는 대부분 암호화된 형태로 특수 파일에 저장하고 이더리움 지갑 소프트웨어로 관리한다
* 외부 소유 계정의 이더리움 주소는 공개키-개인키 쌍의 공개키 부분에서 생성된다.



## Smart Contract

* EVM에서 실행되는 컴퓨터 프로그램



## State

* EVM 코드의 공식적인 실행 모델은 놀라울 정도로 간단하다. 
* 이더리움 가상 머신이 실행되는 동안 상태는 tuple(block_state, transaction, message, code, memory, stack, pc, gas)로 정의된다.
* 각 명령어는 튜플에 어떻게 영향을 미치는지에 대한 자체 정의가 있다. 
  * ADD는 스택에서 두 개의 항목을 pop하여 합계를 push내고 가스를 1씩 줄이고 pc를 1씩 증가시킨다.
  * SSTORE는 상위 두 항목을 스택에서 pop하고 첫 번째 항목이 지정한 인덱스에서 두 번째 항목을 계약 저장소에 삽입한다.



**block_state**

* block_state는 글로벌 state이며 모든 계정과 잔액 및 스토리지를 포함한다.

**PC**

* 현재 수행되는 instruction을 가리킴



## State Transition Function

![ether-state-transition](https://ethereum.org/static/2c0e5e27e397f4ac6b88082fd28d072f/00e09/ether-state-transition.png)

이더리움 상태 전환 함수 APPLY(S,TX) -> S'는 다음과 같이 정의할 수 있다.

1. 트랜잭션이 제대로 구성되어 있는지 확인합니다. 
   * 서명이 유효한지 확인
   * 발신자 계정의 nonce와 트랜잭션의 nonce가 같은지 확인
   * 같지 않으면 오류를 반환
2. 거래 수수료를 STARTGAS * GASPRICE로 계산하고 서명에서 발송 주소를 결정합니다. 
   * 발신자의 계정 잔액에서 수수료를 뺀다.
   * 발신자의 nonce를 증가시킨다.
   * 사용할 잔액이 부족하면 오류를 반환
3. GAS = STARTGAS를 초기화하고 바이트당 일정량의 가스를 차감하여 트랜잭션의 바이트값을 지불합니다.
4. value를 발신자의 계정에서 수신자의 계정으로 이동시킨다.
   * 만약 수신자의 계정이 존재하지 않는다면 생성한다.
   * 만약 수신자가 컨트랙트라면 컨트랙트의 코드를 끝까지 또는 gas 가 모두 소모될 때 까지 수행한다.
   * 만약 거래의 수신자가 컨트랙트가 아니라면
     * 총 거래 수수료는 제공된 가스 가격에 거래 길이를 바이트로 곱한 것과 같다.
5. 발신자의 잔액 부족으로 value전송이 실패하거나 가스 부족으로 code 실행이 실패하면
   * 수수료 지불을 제외한 모든 상태를 복구한다.
   * 그리고 마이너의 계정에 수수료를 준다.
6. 실패하지 않으면 남은 가스 사용료는 모두 발신자에게 환불하고, 소비한 가스 사용료는 마이너에게 보낸다.

> 만약 거래의 수신자가 contract가 아니라면, 총 거래 수수료는 제공된 가스 가격에 거래 길이를 바이트로 곱한 것과 같을 것이고, 거래와 함께 보내진 데이터는 관련이 없을 것이다.



## Transaction

![ether-state-transition](https://ethereum.org/static/2c0e5e27e397f4ac6b88082fd28d072f/00e09/ether-state-transition.png)

* 트랜잭션은 [EOA](#eoa)에서 보낼 메시지를 저장하는 서명된 데이터 패키지를 말한다.
  * [컨트랙트](#contract)는 트랜잭션의 발신자가 될 수 없다.
* 이더리움 네트워크에 위해 전송되고 이더리움 블록체인에 기록된다.
* 트랜잭션은 [EVM](#evm)에서 상태 변경을 유발하거나 컨트랙트를 실행할 수 있는 유일한 방법이다.
* 컨트랙트는 독자적으로 실행되지 않는다 모든 것이 트랜잭션으로부터 시작된다.
* 두 가지 유형의 트랜잭션이 있다
  * 메시지 호출을 발생시키는 트랜잭션
  * 코드를 가진 새로운 계정을 생성하는 트랜잭션(컨트랙트 생성 트랜잭션)



### Transaction Fields

**공통 필드**

* nonce(논스)
  * 발신자 주소에서 보낸 트랜잭션의 수
* gasPrice 와 gasLimit
  * gasPrice : 발신자가 지급하는 가스의 가격(웨이)
  * gasLimit: 이 트랜잭션을 위해 구입할 가스의 최대량
  * [gas](#gas)
* to(수신자)
  * 목적지 이더리움 주소(160비트)
  * 또는 컨트랙트 생성 주소
* value(값)
  * 목적지에 보낼 이더의 양
  * 컨트랙트 생성의 경우 새로 생성되는 컨트랙트 계정의 잔액에 예치된다.
* v, r, s
  * EOA의 ECDSA 디지털 서명의 세 가지 구성요소
  * 트랜잭션의 서명에 해당하는 값들이며 트랜잭션의 발신자를 결정하는 데 사용됩니다.



**message call transaction 필드**

* data
  * 가변 길이 바이너리 데이터 페이로드
  * 데이터 필드는 기본적으로 아무 기능이 없다.
  * EVM에는 계약이 이 데이터에 액세스할 수 있는 opcode가 있다
  * 사용 예시
    * 계약이 블록체인 도메인 등록 서비스로 작동하는 경우, 
    * 전송되는 데이터를 두 개의 "필드"를 포함하는 것으로 해석할 수 있다
    * 계약은 첫번째 필드로 등록할 도메인과 두 번째 필드로 등록할 IP 주소로 읽고 이를 적절하게 storage에 보관할 수 있다.



**contract creation transaction 필드**

* init



## Turing Complete

* 튜링완전(Turing-Complete)는 어떤 프로그래밍 언어나 추상 머신이 튜링머신과 동일한 계산 능력으로 문제를 풀 수 있다는 의미이다.
* 튜링머신(Turing Machine)
  * 추상적인 수학 개념상의 기계이다. 
  * 알고리즘 구현 언이인 튜링완전언어로 구현되며 무한한 저장공간만 있다면 이 세상의 모든 문제를 풀 수 있는 기계를 만드는 것이 가능한데, 그것을 튜링머신이라고 한다.



## Wallet

* 이더리움 계정을 관리하는데 도움을 주는 소프트웨어 애플리케이션
* 지갑은 사용자의 키를 보유하고 사용자를 대신하여 트랜잭션을 생성하고 브로드캐스팅한다.
