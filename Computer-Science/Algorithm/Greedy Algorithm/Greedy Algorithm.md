# 1. Greedy Algorithm

> 그리디 알고리즘이란 바로 눈앞에 이익만을 쫓는 알고리즘을 말한다. 대부분의 경우 뛰어난 결과를 도출하지 못하지만, 드물게 최적해를 보장하는 경우가 있다.



**최적화 문제를 대상으로 적용할 수 있다.**

* 최적해를 찾을 수 있다면 찾는다
* 대부분의 경우 **로컬 최적해**를 찾는 탐욕스런 방식으로 문제를 해결 할 수 없다.
* 따라서 최적해를 찾기 어려운 경우에는 주어진 시간 내에 그런대로 **괜찮은 해**를 찾는다.
  * 근사 알고리즘



**Greedy Algorithm의 장점**

* 최종적으로 최적의 해법을 찾지 못할 수 있으나 충분히 훌륭한 결정을 빨리 내릴 수 있다는 장점이 있다
* 따라서 적당히 좋은 해법도 상관이 없거나 제대로 된 해법을 구하는 알고리즘의 복잡도가 너무 높은 경우 Greedy Algorithm을 고려해볼 수 있다



# 2. Greedy Algorithm이 최적해를 보장하는 문제

> 그리디 알고리즘이 적용되는 문제는 **탐욕 선택 속성**과 **최적 부분 구조**를 가져야한다.



**탐욕 선택 속성(Greedy Choice Property)**

* 앞의 선택이 이후 선택에 영향을 주지 않는 속성
* 한 번 내린 결정은 다시 돌아보지 않는 속성



**최적 부분 구조(Optimal Substructure)**

* 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우를 말한다



# 3. Tip

1. 보통 최소/최대화 문제
2. 정렬을 해야 속도가 빨리질 수도 있다
3. 여러가지 방식으로 그리디 알고리즘이 가능하다면 반례를 통하여 제거할 것

| 알고리즘            | 풀이 가능한 문제의 특징              | 풀이 가능한 문제 및 알고리즘                              |
| ------------------- | ------------------------------------ | --------------------------------------------------------- |
| 다이나믹 프로그래밍 | 최적 부분 구조<br />중복된 하위 문제 | 0-1 배낭 문제<br />피보나치 수열<br />다익스트라 알고리즘 |
| 그리디 알고리즘     | 최적 부분 구조<br />탐욕 선택 속성   | 분할 가능 배낭 문제<br />다익스트라 알고리즘              |
| 분할 정복           | 최적 부분 구조                       | 병합 정렬<br />퀵 정렬                                    |

