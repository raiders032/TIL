# Address

* 비트코인 주소는 수학적으로 공개 키에 해당하며 다음과 같이 보입니다.
* 예시) 1PHYrmdJ22MKbJevpb3MBNpVckjZHt89hz
* 각각의 사용자가 많은 주소를 가질 수 있다

# [Block](https://en.bitcoin.it/wiki/Block)

* 트랜잭션 데이터가 영구 저장되는 공간을 의미한다.



## **Block의 구조**

* Blocksize: 바이트
* Blockheader: 6가지로 구성
* transactions: Transaction 목록



## Block header

* Version: Block version number(4바이트)
* prev_block: 이전 블록의 해시 값(32바이트)
* merkle_root: 해당 블록에 포함된 모든 transactions의 해시인 머클 트리 콜렌션에 대한 참조(32바이트)
* timestamp: 이 블록을 만들 때의 타임스탬프 기록(4바이트)
* bits: 이 블록에 사용되고 있는 난이도(4바이트)
* nonce: 이 블록을 생성하는 데 사용되는 nonce는 헤더의 변형을 허용하고 다양한 해시를 계산하는 데 사용됩니다.(4바이트)
* 총 80바이트로, 1년 동안 발생하는 52,560개의 블록 헤더 용량이 4MB 정도



# Block Chain

* 블록체인은 비트코인 프로토콜 기반의 시스템에 참여하는 모든 노드가 공유하는 트랜잭션 데이터베이스이다. 
* 블록체인의 모든 Transaction이 공개되어 있다
  * 이 정보로 어느 시점에서나 각 주소에 얼마만큼의 코인이있는지 알 수 있다.
* 모든 블록에는 이전 블록의 해시가 포함되어 있습니다. 
  * 이는 제네시스 블록에서 현재 블록까지 블록을 체인처럼 연결하는 효과가 있다.
  * 이러한 특성 때문에 한 블록을 수정하기가 어렵다 블록이 체인처럼 연결되어 있기 때문에 해당 블록 이후의 블록도 재생성해야된다.
  * 따라서 시간이 지남에 따라 블록이 추가될 것이고 
  * 이러한 특성들이 Transaction을 되돌릴 수 없게 만든다.

# Coinbase

* 코인베이스는 모든 블록의 첫 번째 거래에 주어진 특별한 이름이다. 이를 `Generation Transactions`라고도 한다.
* POW 작업에 대해 마이너를 보상하기 위해, 모든 블록의 마이너는 인풋없이 자신에게 25 BTC를 주는 트랜잭션을 블록 맨앞에 포함시킨다.
* BTC가 발행되는 유일한 메커니즘이다
* genesis 상태에는 coin이 전혀 존재하지 않았다

# [Confirmation](https://en.bitcoin.it/wiki/Confirmation)

* 트랜잭션이 네트워크로 브로드캐스트된 후 블록에 포함되어 네트워크에 공표된다. 
  * 이 상태를 Transaction이 1블록 깊이에서 채굴되었다고 한다.
  * 이후 블록이 추가될 때마다 블록 깊이가 1씩 증가한다.
  * 이중 지출로부터 안전하기 위해, Transaction이 일정 블록 깊이가 될 때까지 Confirmation된 것으로 간주해서는 안 된다.
* Confirmation 되지않은 트랜잭션은 만료되지 않는다.
* 6개의 블록이 Transaction을 Confirmation할 때까지 거래를 "Unconfirmed"로 표시한다

# Difficulty

* `Difficulty`는 주어진 `Target` 아래의 해시를 찾는 것이 얼마나 어려운지를 나타내는 척도이다.
* 비트코인 네트워크는 글로벌한 `Difficulty` 를 공유한다.
* 유효한 블록은 해시 값이  `Target` 보다 작아야 한다.
* 2016 블록마다 `Difficulty`가 변한다.

# Double-Spending

* 다른 트랜잭션에서 이미 사용된 코인을 또 다시 사용하는 것



# Full Node

* 풀노드(full node)는 블록체인의 모든 내역을 저장하는 노드이다.
  * 제네시스 블록부터 시작해서 현재 블록까지 모든 블록체인 정보를 수집, 저장한다
* PC에 모든 내역이 저장되어 있기 때문에 스스로 거래 검증이 가능하다
* 모든 내용을 저장하기 위해 소요되는 시간이 길고 큰 용량이 필요하다는 단점이 있다.
  * 이런 풀노드의 단점을 해결하기 위해 나온 것이 [라이트노드](#light-node)이다.
* 방대한 양의 데이터를 다운받고 검증하는 시스템을 갖춘 만큼, 방대한 양의 데이터를 소화할 수 있는 대규모 채굴업 관련 종사자들에게 필요한 기술이라고 할 수 있다
* 풀노드는 블록체인 데이터를 동기화하기 위헤 메모리를 사용한다.



**Full Node의 역할**

1. 거래가 진행될 때 각 거래자들의 계좌정보, 잔액 등의 정보확인을 통해 유효한 거래인지 확인한다.
2. 전체 기록을 다 가지고 있기에, 새로운 블록이 추가될 때 조작이 없는지 이전 거래와 내역이 일치하는지 등을 누구의 도움 없이 모든 거래에 대한 검증이 가능하다.
3. 새로운 블록이 생성된 후 채굴을 성공한 채굴자에게 올바르게 보상이 제공되었는지 확인한다.
4. 블록에서 이중 지불이 발생하지 않았는지를 확인한다.
5. 본인이 가진 기록정보를 다른 노드들에게 전달하는 일을한다.

# [Hash](https://en.bitcoin.it/wiki/Hash)

* 간략히 말하면 요약을 하는 것 일정한 길이의 결과물이 나온다
* 해시 알고리즘은 임의의 많은 양의 데이터를 고정 길이의 값으로로 변환하는 것을 말한다.
* 동일한 해시가 항상 동일한 데이터에서 발생하지만, 1비트의 데이터를 수정해도 해시가 변경됩니다. 
* 모든 컴퓨터 데이터와 마찬가지로 해시는 큰 숫자이며 일반적으로 16진수로 작성된다.
* 비트코인은 SHA-256 해시 알고리즘을 사용하여 예측 가능한 CPU의 노력을 요구하는 방식으로 검증 가능한 난수들을 생성한다. 
* 현재 `Target`보다 작은 값의 SHA-256 해시를 생성하면 블록이 해결되고 코인을 획득할 수 있다



# [Irreversible Transactions](https://en.bitcoin.it/wiki/Irreversible_Transactions)

* 올바르게 사용한다면 블록체인의 기본 계층 Transaction는 되돌릴 수 없고 최종적이다. 
* Block Chain, Mining, POW, Difficulty 등의 비트코인 시스템은 수정할 수 없는 transaction의 역사를 만들기 위해 존재한다고 할 수 있다
* 전자 화폐에 관한 문헌에서 이 속성은 종종 "이중 지출 문제 해결"로 언급되었다. 
* 이중지출은 한 번 이상 성공적으로 돈을 쓴 결과입니다.
* 비트코인 이용자들은 블록체인에서 결제를 받을 때 `Confirmation`을 기다리며 이중 지출 사기로부터 자신을 보호하는데, `Confirmation` 횟수가 늘어날수록 거래는 더욱 수정할 수 없게 된다.



# Light node

* 라이트노드는 블록체인 거래내역 중 일종의 핵심본만 저장하는 노드이다. 
* 모든 블록 정보를 가지고 있지 않고, 필요한 부분만 저장한다는 특징이 있다.
  *  즉 블록헤더에 있는 중요한 데이터만 보유하고 있다.
* 모든 블록정보를 가지고 있지 않기 때문에 어떤 새로운 거래 정보를 수신받았을 경우 이 거래가 정상적인지 검증할 수 없다.
* 라이트노드는 블록체인에 참여하여 거래를 수행하는 노드로, 풀노드에 거래 데이터를 요청하여 개별 거래를 검증하는 기능을 수행한다.
  * [SPV](#SPV)

# [Majority attack](https://en.bitcoin.it/wiki/Majority_attack)

* Majority attack(보통 51% 공격 또는 50% 공격)은 네트워크에 대한 공격이다. 
* 공격자가 자신의 체인을 가장 길게 만들기 위해선 나머지 노드들의 컴퓨팅 파워를 합친 것 보다 더 많은 컴퓨팅 파워가 필요하다
* 이러한 공격을 Majority attack이라 한다.

# Merkle Tree

![spv-bitcoin](https://ethereum.org/static/47aecc91895df6cd1b3e8089aa7e9a7c/e4900/spv-bitcoin.png)

* 머클트리(Merkle Tree)는 블록에 포함된 거래 내역을 요약한 것이다.
* Merkle 트리는 이진 트리의 일종이다.
  * 머클 트리는 많은 노드로 구성된다
  * 리프 노드에는 저장하고자 하는 데이터가 들어있다.
  * 중간 노드는 두 자식의 해시이다.
  * 루트 노드 또한 두 자식의 해시이다.
  * 이 과정을 통해 다수의 데이터를 하나로 묶어 용량을 절약할 수 있다.
  * SHA256 해시를 사용

**용도**

* 머클트리에서는 모든 거래내역들을 해시화한 **머클루트를 통해 거래내역의 변동여부를 쉽게 확인**할 수 있다
  * 머클트리 자체가 해시로 이루어진만큼 하나의 트랜잭션 혹은 블록 내 필드값이 변조될 경우 머클루트 해시 값이 변조되는 쇄도 효과(avalanche effect)가 발생한다. 
* 머클루트를 헤더에 담아 트랜잭션의 유효성을 보장한다.
* 머클 경로(Merkle path)를 제공받아 **특정한 트랜잭션이 블록에 유효하게 있는 효율적인 검사가 가능**하다. 
* 머클트리는 모든 정보를 압축하여 간단하게 표현한 데이터로서 머클트리를 통해 데이터의 간편하고 확실한 인증이 가능하다
* 머클트리 프로토콜은 비트코인 네트워크를 장기간 지속가능하게 만드는 기초가 된다
  * 모든 블록 전체를 저장하고 처리하는 비트코인 네트워크의 "풀 노드"는 2014년 4월 비트코인 네트워크에서 약 15GB의 디스크 공간을 차지하며 매월 1기가바이트 이상 커짐
* 가벼운 노드는 블록헤더를 다운로드하고 그 블록헤더에서 작업증명을 검증한다. 
  * 그리고 관련 트랜잭션들에 대한 "곁가지들(branches)"만을 다운로드 한다. 
  * 이렇게 전체 블록체인의 매우 작은 비율만을 다운로드 함에도 불구하고 강한 안전성을 보장하면서도, 임의의 트랜잭션의 상태 및 잔고 상태를 알아낼 수 있게 한다.



**구성요소**

* 머클루트 
  * 블록이 보유하고 있는 거래 내역들의 해시값을 가장 가까운 거래내역끼리 쌍을 지어 해시화하고 쌍을 지을 수 없을 때까지 이 과정을 반복했을 때 얻게 되는 값이다. 
  * 이는 블록에 저장되어 있는 모든 거래의 요약본으로 해당 블록에 포함된 거래로부터 생성된 머클트리의 루트에 대한 해시정보가 담겨있다. 
  * 아무리가 거래가 많이 발생하여도 하나로 압축된 머클 루트의 용량은 항상 32 바이트이다
* 머클 경로 
  * 머클 경로(Merkle path)는 어떤 거래의 진위를 따질 때 이를 검증하는 과정이다. 
  * 머클루트가 주어진다면, 좀 더 쉽게 검증이 가능하다.

# Mining

* 마이닝의 주된 목적은 거래의 역사를 어느 한 실체가든 전산적으로 수정할 수 없는 방식으로 설정하는 것이다. 블록체인을 다운로드하고 검증함으로써 비트코인 노드들은 비트코인의 이벤트 순서에 대한 합의에 도달할 수 있다.
* 거래 내역을 담은 블록을 만드는 과정
* 블록을 만들기 위해서 어려운 수학 문제를 풀어야한다.
  * 한 10분 정도 걸리게 문제의 난이도는 자동적으로 조절됨
* 유저가 문제의 해답을 찾으면 해답을 네트워크에 알린다.
  * 찾은 해답과 몇가지 정보를 묶어 패키지화 한것이 블록이다
* 블록을 만든다는 것은 해당 블록이 진짜임을 증명하는 것
  * 해당 블록에 포함된 거래내역들이 진짜라는 것
  * 이를 합의 메커니즘이라고 한다.
* 대표적인 합의 메커니즘
  * 작업 증명
  * 지분 증명

**보상**

* 올바른 블록을 가장 먼저 만들게되면 신규 비트코인이 보상으로 지급된다.
* 시작 당시 50개 대략 4년 마다 반감된다.
* 비트코인 매장량을 21백만개로 정해져있다
* 2140년 정도에 채굴완료 예정
* 그 이후에는 블록 생성 대가로 수수료만 받는다
  * 거래에는 수수료가 붙는데 그것을 블록을 만드는 사람이 가져가는 것으로 동기부여한다.



![ethereum-blocks](https://ethereum.org/static/6f7d50fd4fab9f8abb94b5e610ade7e4/bf8c1/ethereum-blocks.png)

* 비트코인을 통해 우리는 탈중앙화 화폐 시스템을 구축하려 하고 있기 때문에 모든 사람이 거래 순서에 동의하도록 하기 위해 State Transition System과 합의 시스템을 결합할 필요가 있을 것이다.
* 비트코인의 분산된 합의 프로세스는 네트워크상의 노드들이 "블록"이라고 불리는 트랜잭션 패키지를 지속적으로 생성하려고 시도하도록 요구한다.
* 네트워크는 10분마다 대략 하나의 블록을 생성하도록 되어 있다
* 각 블록은 타임스탬프, 논스, 이전 블록(해시)과 이전 블록 이후 발생한 모든 트랜잭션의 목록으로 구성된다.
* 시간이 지남에 따라 비트코인 원장의 최신 상태를 나타내기 위해 끊임없이 업데이트되는 "블록체인"을 만든다.



**블록 유효성 검사 알고리즘**

* 하나의 블록이 유효한지 아닌지를 확인하기 위한 알고리즘

1. 블록에서 참조한 이전 블록이 존재하며 유효한지 확인합니다.
2. 블록의 타임스탬프가 이전 블록의 타임스탬프 보다 크면서 2시간 이내인지 확인합니다.
3. 블록의 작업증명이 유효한지 확인합니다.
4. S[0]를 이전 블록의 끝에 있는 상태라고 하자.
5. TX가 n개의 트랜잭션이 있는 블록의 트랜잭션 리스트라고 가정해 보자. 
   * 0...n-1의 모든 i에 대해 S[i+1] = APPLY(S[i],TX[i]) 
   * 오류를 반환하는 경우 종료하고 false를 반환합니다.
6. true를 반환하고 S[n]를 이 블록의 끝에 있는 상태로 등록합니다.

* 블록의 각 트랜잭션은 트랜잭션이 실행되기 전의 표준 상태에서 어떤 새로운 상태로 유효한 상태 전환을 제공해야 한다.
* **상태는 블록에 인코딩되지 않는다.**
* 상태는 검증 노드에 의해 기억되어야한다.
* 상태는 발생 상태에서 시작하여 모든 블록의 모든 트랜잭션을 순차적으로 적용함으로써 계산될 수 있다.



# POW

![pow](./images/pow.png)

* POW의 조건은 256 비트의 숫자로 표현되는 각 블록의 이중-SHA256 해시가 동적으로 조정되는 target보다 반드시 작아야한다.
* 블록 생성을 전산적으로 '힘들게' 만들어 공격자가 자신들에게 유리하게 전체 블록체인을 다시 만드는 것을 막는 것이 목적이다. 
* SHA256은 완전히 예측할 수 없는 유사 난수 함수로 설계되었으므로 유효한 블록을 생성하는 유일한 방법은 시행착오를 반복하여 nonce를 증가시키고 새 해시가 일치하는지 확인하는 방법밖에 없다.
* 평균적으로 10분마다 새로운 블록이 생성되도록 2016 블록마다 네트워크에 의해 target이 조절된다.



# **공개키 암호 시스템 주요 용도**

* 암호화: 퍼블릭 키로 암호화 프라이빗 키로 복호화
  * A가 B에서 암호화된 문서를 보내고 싶다
  * A가 문서를 B의 공개키로 암호화해서 보낸다.
  * B는 문서를 받아서 자신의 비밀키로 복호화 한다. 즉 B만 열어볼 수 있다.
* 전자서명: 프라이빗 키로 암호화 퍼블릭 키로 복호화
  * A가 해당 문서를 자신이 작성했음을 증명하고 싶다
  * A가 문서를 자신의 비밀키로 암호화
  * 누구나 A의 공개키로 검증 가능

* 



# Target

* Target은 모든 비트코인 클라이언트가 공유하는 256비트 숫자(아주 큰 숫자)입니다. 
* 블록 헤더의 SHA-256 해시는 블록이 네트워크에서 허용되려면 현재 대상보다 작거나 같아야 합니다. 
* Target이 낮을수록 블록 생성이 어려워진다.



# State Transition System

![ethereum-state-transition](https://ethereum.org/static/0aeff9bcdfb1f5fd002610b4a5cff197/460fa/ethereum-state-transition.png)

* 비트코인과 같은 암호화 화폐의 장부는 하나의 상태 변환 시스템(state transition system)으로 생각해볼 수 있다

* 상태

  * 현재 모든 비트코인의 소유권 현황으로 이루어진 하나의 상태
  * 아직 사용되지 않은 코인(UTXO)들의 집합
    * 각 UTXO는 액면금액과 소유자가 있다.
    * 소유자: 20byte 의 주소로 정의되는 암호화된 공개키

* 거래

  * 거래는 하나 이상의 입력을 포함한다
  * 각 입력은 현재 사용되는 UTXO와 소유자의 주소와 관련된 개인 키에 의해 생성된 암호화 서명을 포함한다.
  * 각 출력은 상태에 추가될 새로운 UTXO들이다.

* 상태 변환 함수

  * **상태와 거래를 가지고 그 결과 새로운 상태를 출력하는 함수**

  * 각 **입력**에는 보내는 쪽 지갑주소에서 선택된 기존 **UTXO** 에 대한 참조정보와, 해당지갑주소에 대응되는 개인키(private key)가 생성한 암호화된 서명을 담고 있다. 

  * 각 **출력**들은 상태에 추가될 **새로운 UTXO** 정보를 가지고 있다.

  * ```
    APPLY(S,TX) -> S' or ERROR
    APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }
    ```



**비트코인 거래**

1. TX의 각 입력에 대해:
   * 참조된 UTXO가 S에 없다면 오류를 반환합니다. -> 존재하지 않는 코인
   * 제공된 서명이 UTXO의 소유자와 일치하지 않으면 오류를 반환합니다. -> 다른 사람의 코인을 사용하지 못함
2. 모든 입력 UTXO의 합계가 모든 출력 UTXO의 합보다 작으면 오류를 반환합니다.
3. 모든 입력 UTXO가 제거되고 모든 출력 UTXO가 추가된 상태를 반환합니다.



**비트코인 거래 예시**

1. 앨리스는 밥에게 11.7 BTC를 보내고싶다
2. 먼저, Alice는 최소 11.7 BTC이상의 이용 가능한 UTXO들을 찾는다. 
3. 현실적으로, 앨리스는 정확히 액면가가 11.7 BTC인 UTXO를 얻을 수 없을 것이다; 
4. 그녀가 얻을 수 있는 가장 작은 UTXO들의 합은 6+4+2=12(UTXO)라고 가정하자. 
5. 그리고 나서 그녀는 그 세 개의 입력과 두 개의 출력으로 거래를 만든다.
6. 첫 번째 출력물은 밥의 주소를 소유자로 둔 11.7 BTC이며, 두 번째 출력물은 나머지 0.3 BTC "잔돈"으로 소유자는 앨리스 자신이 될 것이다.



# SPV

* SPV(Simple Payment Verification)
* SPV는 모든 블록체인을 다운로드 하지 않고 거래를 검증하는 간이 결제 확인 방법이다
* [라이트노드](#light-node)는 개별 거래에 대한 트랜잭션을 확인하기 위한 SPV(Simple Payment Verify, 단순 지불 검증)를 사용한다.
* SPV는 라이트노드에서 거래를 검증하기 위해 풀노드에게 블록정보를 요청하여 머클트리를 통해 이 거래가 검증된 거래인지를 확인하는 방법이다.

**문제점**

* SPV는 풀 노드들에 정보를 요청해야만 거래를 진행할 수 있기 때문에 풀 노드에 대한 정보의 의존도가 높다. 
* 풀 노드의 경우 처음부터 블록체인을 저장해왔고 최종적으로 돈이 들어 있는 계좌(UTXO)를 블록체인이 아닌 데이터베이스에 저장하기 때문에 더 빠른 속도로 처음부터 자신의 잔고를 확인할 수 있지만, SPV의 경우 다른 풀 노드에 의지하기 때문에 처음부터 제대로 된 정보를 주느냐가 문제이다. 
* 악의적 노드가 끼어들게 되면 SPV로써는 구분할 수 없기 때문에 큰 문제로 이어질 수 있으며 다른 노드들이 거래를 취소를 시켜버림으로써 거래지연이 발생하게 된다

# Transaction

* Transaction은 네트워크로 브로드캐스트되어 블록으로 수집되는 비트코인 가치를 전송하는 것입니다. 
* 트랜잭션은 일반적으로 이전 트랜잭션 출력을 새로운 트랜잭션 입력으로 참조하고 모든 입력 비트코인 값을 새로운 출력으로 전용합니다. 
* 트랜잭션은 암호화되지 않으므로 블록으로 수집된 모든 트랜잭션을 검색하고 볼 수 있습니다. 
* 일단 Transaction이 충분한 Confirmation을 받게 되면, Transaction은 되돌릴 수 없는 것으로 간주될 수 있다.
* 모든 트랜잭션는 해시를 가지고있다.

# Transaction expiration

* Transaction이 만료되는 것은 많은 사람들이 하는 흔한 오해이다. 
* 비트코인 Transaction은 한 번 생성되면 절대 자동으로 만료되지 않는다. 
* 이론적으로, 거래가 생성되어 몇 년 동안 0 확인에 갇혀 있다가 갑자기 확인될 수 있다



참고

* http://wiki.hash.kr/index.php/%EB%8C%80%EB%AC%B8