## Account

* 이더리움에서 state는 `account`라고 불리는 객체로 구성된다
* account는 20바이트 주소를 가진다
  * 비밀키 -> 공개키
    * 비밀키를 ECDSA으로 패어링
  * 공개키 -> 주소
    * Keccak-256을 사용하여 공개키의 해시를 계산하고 마지막 20바이트가 주소가된다.
* 이더리움의 State는 각 Account들의 상호 메시지 전달 프레임워크를 통해 변환됨



### **Account Fields**

* account의 state는 4가지의 필드로 구성된다.
* nonce
  * 각 트랜잭션이 한 번만 처리될 수 있도록 하기 위해 사용되는 카운터
  * [외부 소유 계정](#eoa) 계정인 경우`이 주소에서 보낸 트랜잭션의 수` 
  * [컨트랙트 계정](#contract account)인 경우 `이 계정으로 만든 컨트랙트 생성 수`
  * 최초에 0으로 초기화되어 있다.
* balance
  * 이 주소에 의해 소유된 이더(Wei)의 양
* codeHash
  * 외부 소유 계정의 경우: 빈 문자열의 Hash
  * 컨트랙트 계정의 경우 : 계정의 EVM 코드 해시
  * 주소가 메시지 수신할 경우 실행되는 코드입니다.
  * 코드는 불변하므로 다른 필드와 달리 생성 후에 바뀌지 않는다.
  * 이러한 모든 코드 조각은 나중에 검색할 수 있도록 해당 해시의 상태 데이터베이스에 포함되어 있습니다.
* storageRoot
  * 생성 초기 비어있다.
  * 계정의 storage 내용을 인코딩하는 Merkle Patricia 트리의 루트 노드에 대한 256비트 해시



### EOA

* 외부 소유 계정(Externally Owned Accounts)
  * Ethereum 네트워크의 사용자(사람)에 의해 생성된 계정입니다.

* 외부 소유 계정은 개인키가 있는 계정이다
  * 개인키를 갖는다는 건, 자금 또는 컨트랙트에 대한 접근을 제어한다는 뜻이다.

* code를 가지고 있지 않다
* [트랜잭션](#transaction)을 만들고 서명함으로써 메시지를 전송할 수 있다.



### **Contract Account**

* 스마트 컨트랙트 코드를 가지는 계정
* 컨트랙트 계정은 개인키가 없다.
  * 대신 스마트 컨트랙트 코드의 로직으로 통제된다
  * 트랜잭션을 시작할 수 없다(컨트랙트의 발신자가 될 수 없다)
  * EOA만 트랜잭션을 시작할 수 있다.

* 스마트 컨트랙트 코드는 컨트랙트 계정 생성 시 이더리움 블록체인에 기록되고 [EVM](#evm)에 의해 실행되는 소프트웨어 프로그램이다.
* 메시지를 받을 때 마다 코드가 작동한다
  * [트랜잭션](#transaction) 목적지가 컨트랙트 주소일 때 트랜잭션과 트랜잭션 데이터를 입력으로 사용하여 컨트랙트가 EVM에서 실행된다.
  * 트랜잭션에는 실행한 컨트랙트의 측정 함수와 해당하는 함수에 전달할 파라미터를 나타내는 데이터를 포함할 수 있다.

* storage를 읽고 쓸 수 있다
* 메시지를 보내거나 [컨트랙트](#contract)를 만들 수 있다.





## Address

* 주소는 일반적으로 [트랜잭션](#transaction)을 수신하거나 전송할 수 있는 [EOA](#eoa) 또는 [계약](#contract)을 나타낸다. 
* 주소 = ECDSA 공개 키의  Keccak hash의 가장 오른쪽 160비트



## Block

* 비트코인의 블록과 유사하지만 차이점이 있다.
  * 주요 차이점으로는 비트코인과는 달리 이더리움 블록은 트랜잭션 리스트와 **가장 최근의 상태(state) 복사본을 가지고 있다는 것**이다. 
* 블록 구성요소
  * transaction 리스트
  * 최신 state
  * 블록 넘버
  * difficulty



### Bolck Headers

* number
  * 부모 블록의 수
  * 제네시스 블록은 number가 0
* parentHash 
  * 부모 블록 헤더의 해시(The Keccak 256-bit hash)
* timestamp
  * 블록 생성시 시간
* beneficiary
  * 160비트 주소
  * 채굴 승자에게 주어지는 수수료의 합을 이 주소로 전송한다.
* difficulty
  * 블록의 난이도
  * 블록의 난이도는 이전 블록의 난이도와 타임스탬프로 계산된다.
* gaslimit
  * 블록당 소비할 수 있는 최대 가스 양
  * 현재 gaslimit은 6,712,096gas로 한 블록에 Standard Transaction (21,000Gas)을 약 319개 넣을 수 있는 양임.
* gasUsed
  * 블록의 트랜잭션들에서 사용된 가스의 총 양
* stateRoot
  * 모든 트랜잭션이 실행되고 종료된 후 상태 트리의 루트 노드의 해시(The Keccak 256-bit hash)
  * 세계 상태(World State: 모든 계정들의 상태의 전체 집합)는 Merkle-Particia 트리의 형태로 각 노드에 저장되고 각 블록에는 세계 상태 트리의 최상위 노드만 저장한다.
* transactionsRoot
  * 트랜잭션으로 채워진 트리 구조의 루트 노드의 Keccak 256비트 해시
  * 블록에 포함된 모든 거래는 트리 형태로 저장되고 각 노드에 저장되고 블록에는 거래 트리의 최상위 노드만 저장한다.
* receiptsRoot
  * 모든 거래는 영수증을 발생시키고 이렇게 각 거래에 대응되는 영수증 집합은 트리 형태로 저장된다. 
  * 블록에는 영수증 트리의 최상위 노드만 저장한다.
* logsBloom
  * Log 정보로 구성된 Bloom Filter
* extraData
  * 이 블록과 관련된 추가 Data
* mixHash
  * Ethash(작업증명)의 연산 결과로 생성되는 해시 (32바이트)
* nonce
  * Ethash(작업증명)에서 사용된 논스
* Uncles Hash(ommersHash)
  * 이 블록의 Uncle에 해당하는 Block List의 Hash 값



### Block Validation Algorithm

* 기본적인 이더리움 블록 검증 알고리즘은 다음과 같다.

![ethereum-apply-block-diagram](https://ethereum.org/static/479308517ae57f0198f0a43f893884c3/89557/ethereum-apply-block-diagram.png)

1. 이전 참조되는 블록이 존재하고 유효한지 검사
2. 현재 블록의 타임스탬프가 참조하고 있는 이전 블록의 그것보다 크면서, 동시에 현 시점을 기준으로 15 분 후보다 작은 값인지 확인한다.
3. 해당 블록의 블록 넘버, difficulty, 트랜잭션 루트, 언클 루트, gas limit이 유효한지 검사
4. 해당 블록의 POW가 유효한지 검사
5. S[0]를 이전 블록의 마지막 상태라고 하자
6. TX를 블록에 포함될 transaction N개의 리스트라고 하자
   * 모든 i 에 대해서 `S[i+1] = APPLY(S[i],TX[i])` 라고 설정
   * 블록에서 소비된 총 가스가 GASLIMIT를 초과할 경우 오류를 반환한다.
7. 채굴자에게 지불된 보상 블록을 S[n] 덧붙인 후 이것을 S_FINAL 이라 하자.
8. 상태 S_FINAL 의 머클 트리 루트가 블록 헤더가 가지고 있는 최종 상태 루트와 같은지를 검증한다. 
   * 이 값이 같으면 그 블록은 유효한 블록이며, 다르면 유효하지 않은 것으로 판단한다.



**Block과 State**

* 모든 상태를 각 블록에 저장하는 것은 매우 비효율적인 것처럼 보이지만, 실제로는 효율성의 측면에서는 비트코인과 비교할만 하다. 
* 그 이유로는 상태가 트리 구조로 저장되고, 모든 블록 후에 단지 트리의 작은 부분만이 변경되기 때문이다. 
* 보통, 인접한 두개의 블록간에는 트리의 대부분의 내용이 같고, 따라서 한번 데이터가 저장되면 포인터(서브트리의 해쉬)를 사용하여 참조될 수 있다.
* 패트리시아 트리(Patricia tree)로 알려진 이러한 종류의 특별한 트리는 머클 트리 개념을 수정하여 노드를 단지 수정할 뿐만 아니라, 효율적으로 삽입되거나 삭제하여 이러한 작업을 수행할 수 있도록 해준다. 
* 모든 상태 정보가 마지막 블록에 포함되어 있기 때문에, 전체 블록체인 히스토리를 모두 저장할 필요가 없어지게 된다. 
* 이 방법을 비트코인에 적용한다면 5 - 20 배의 저장 공간 절약의 효과가 생길 것이다.



### Stale Block

<img src="./images/stale-block.png" alt="image-20211103171645657" style="zoom:50%;" />

* 블록생성에 성공하였고, 검증 작업시, 오류가 없어서 네트워크를 통해 전파되었으나, 더 빨리 전파 된 다른 채굴자에 의한 블록에 순위가 밀리는 바람에 주체인에 산입되지 못한 블록이다.
* 이더리움과 같은 짧은 블록 생성 주기(15초)를 가지는 블록체인에서는 스테일 블록이 생성될 확률이 높다.
* 이더리움에서는 스테일 블록도 여전히 주체인블록 보상의 87.5%만큼의 보상을 받으며 보안성을 강화하는 역할을 수행하게 된다.
* [GHOST Protocol](#ghost-protocol)



## Blockchain

* 퍼블릭 블록체인의 구성 요소
  * 표준화된 가십 프로토콜을 기반으로 참여자를 연결하고 트랜잭션 및 검증된 트랜잭션 블록을 연결하는 P2P 네트워크
  *  상태 전이를 나타내는 트랜잭션 형식의 메시지
  * 트랜잭션의 구성 요건과 트랜잭션의 유효성을 판단하는 합의 규칙의 집합
  * 합의 규칙에 따라 트랜잭션을 처리하는 상태 머신
  * 검증되고 적용된 모든 상태 전이의 장부 역할을 해줄 수 있는, 암호학적으로 보호된 체인
  * 합의 규칙들을 적용하는데 모든 참여자가 협력할 수 있도록 강제함으로써 블록체인의 통제 권한을 탈중앙화하는 합의 알고리즘
  * 공개된 환경에서 상태 머신에 경제적인 보안성을 제공할 수 있는 게임 이론적으로 유효한 인센티브 메커니즘
  * 위에서 언급한 것들을 구현한 하나 이상의 오픈 소스 소프트웨어
* 블록체인 핵심 특성
  * 개방성
  * 공공성
  * 국제화
  * 탈중앙화
  * 중립성
  * 검열 저항성



## Consensus Algorithm

* 합의 알고리즘이란 피투피 네트워크와 같이 정보 도달에 시간차가 있는 네트워크에서 여러 참가자들이 하나의 단일한 결과에 대한 합의를 얻기 위한 알고리즘이다.
* 블록체인 시스템의 경우 네트워크에 참여하는 모든 참여자들이 동일한 데이터를 복사하여 분산 저장하기 때문에 원본과 사본의 구별이 없으며, 통일된 의사결정을 내릴 수 있는 권위 있는 중앙(center)이 존재하지 않는다. 
  * 이런 상황에서 합리적이고 효율적인 의사결정을 내릴 수 있는 다양한 알고리즘이 개발되었다.



## Contract

* 컨트랙트는, 수행되거나 컴파일 되어야 할 어떤 것이라기 보다는이더리움의 실행 환경안에 살아있는 일종의 자율 에이전트이다
* 컨트랙트는 자신이 소유한 ether balance와 key/valuce store 대한 직접적인 통제권을 가지고 있다.



**컨트랙트 코드 작성**

```solidity
contract Faucet {
    function () public payable {}

    // Give out ether to anyone who asks
    function withdraw(uint withdraw_amount) public {
        // Limit withdrawal amount
        require(withdraw_amount <= 100000000000000000);

        // Send the amount to the address that requested it
        msg.sender.transfer(withdraw_amount);
    }
}
```

* `msg`
  * 모든 컨트랙트에서 접근할 수 있는 입력 중 하나
  * 이 컨트랙트의 실행을 시작한 트랜잭션을 나타낸다.
* `msg.sender`
  * 트랜잭션의 발신자 주소
* `msg.sender.transfer()`
  * 이더를 현재 컨트랙트에서 발신자의 주소로 전송한다는 뜻이다
* `receive() external payable {}`
  * 소위 폴백 또는 기본함수
  * 컨트랙트를 실행한 트랜잭션이 컨트랙트에 선언된 함수 또는 어떤한 함수도 지정하지 않거나 데이터를 포함하지 않을 경우 호출된다.
  * 컨트랙트는 하나의 기본 함수를 가질 수 있다
  * 일반적으로 이더를 받는 함수이다.



**Contract의 생성**

* 솔리디티로 작성한 스마트 컨트랙트는 [EVM](#evm)에서 사용되는 바이트 코드로 컴파일되어야 한다.
* 컴파일된 컨트랙트 코드는 특수한 형태의 [트랜잭션](#transaction)을 통해 이더리움 블록체인에 배포가 되고 이때부터 공개된다.
  * 스마트 계약의 배포를 위해서는 수신자의 주소가 0으로 지정된 특수한 형태의 트랜잭션을 발생시켜야 한다.
* 컨트랙트가 생성되면 지갑과 마찬가지로 주소를 가지게된다.



**Contract의 실행**

* 컨트랙트는 메시지나 [트랜잭션](#transaction)을 트리거로 항상 특정 코드를 실행하는 자동화된 에이전트이다
* 트랜잭션의 목적지가 컨트랙트 주소일 때 트랜잭션과 트랜잭션 데이터를 입력으로 사용하여 컨트랙트가 EVM에서 실행된다.
* 트랜잭션에는 이더, 데이터가 포함된다
  * 이더가 포함되어 있으면 컨트랙트 잔액에 예치된다.
  * 데이터가 포함되어 있으면 데이터에서는 컨트랙트에서 명명된 함수를 지정하고 호출하여 함수에 인수를 전달할 수 있다
* 이렇게 트랜잭션은 컨트랙트 내의 함수를 호출할 수 있다.



## Code Execution

* 이더리움 Contract의 코드는 "이더리움 가상 머신 코드" 또는 "EVM 코드"라고 하는 저수준의 스택 기반 바이트코드 언어로 작성된다. 
* 이 코드는 연속된 바이트로 구성되어 있고, 각각의 바이트는 연산(operation)을 나타낸다. 
* 일반적으로 코드 실행은 코드 끝에 도달하거나 오류 또는 STOP 또는 RETURN 명령이 감지될 때까지 현재 프로그램 카운터(0에서 시작)에서 작업을 반복적으로 수행한 다음 프로그램 카운터를 하나씩 증가시키는 무한 루프이다. 
* operation은 데이터를 저장할 수 있는 세 가지 유형의 공간에 액세스할 수 있습니다.
  * 스택: 값을 넣고 뺄 수 있는 선입선출 저장소
  * 메모리: 무한 확장 가능한 바이트 배열
  * 스토리지: 계약의 장기 보관, 키/밸류 스토어. 연산이 끝나면 리셋되는 스택이나 메모리와 달리 스토리지는 장기간 지속된다.
* 코드는 또한 블록 헤더 데이터뿐만 아니라 특정 값이나, 발송자 및 수신되는 메시지의 데이터에 접근할 수 있고, 결과값으로 데이터의 바이트 배열을 반환할 수도 있다.
* 물리적인 하드웨어 관점에서 볼 때, 컨트랙트 코드는 “어디에서" 실행되는가?
  * 트랜잭션이 블록 B 에 포함되면 그 트랜잭션에 의해 발생할 코드의 실행은 현재 또는 향후에 블록 B 를 다운로드 하고 검증하는 모든 노드들에 의해 실행될 것이다



## Dapp

* Dapp은 공개되고 탈중앙화된 피어투피어 기반 서비스 위에 제공되는 웹 애플리케이션



**Dapp의 특징**

* 오픈 소스
  * 개발한 소스 코드가 모두 공개되어 있으므로 사용자를 속이고 무단으로 정보를 빼가는 것(위치 정보 수집 등)이 불가능.
* 자율적 수행
  * 한번 배포된 Dapp은 코드에 따라 자율적으로 수행됨. 개발자를 포함한 외부의 개입이 원천적으로 차단됨.
* 보안성
  * 블록체인의 보안성에 의존하고 있으므로 해커의 침입 및 데이터의 위조로부터 안전함.
* 100% 가용성
  * 중앙화된 서버와는 다르게 점검 혹은 트래픽으로 인한 장애가 없이 항상 가동되고 있음을 보장함.



**Dapp의 구성 요소**

* 최소 구성 요소
  * 블록체인 스마트 컨트랙트
  * 웹 프론트엔드 사용자 인터페이스
* 추가 요소 
  * 탈중앙화 스토리지 프로토콜과 플랫폼
  * 탈중앙화 메시지 프로토콜과 플랫폼



**Dapp의 종류**

* 토큰 시스템
  * 새로운 암호화폐, 주식, 스마트 자산, 위조불가능한 쿠폰, 포인트 시스템 등 
* 탈중앙화된 자율조직(DAO) 
  * 특정한 집합의 구성원 또는 주주를 갖고 있는 가상 독립체가 코드에 의해 운영됨
* 다중서명 공탁 계좌
  * 5명 중 4명이 동의하면 전체 금액, 5명 중 3명이 동의하면 10%를 사용 등 설계
* 클라우드 컴퓨팅
  * 빅데이터, 과학 연구, 유전자 분석 등 작업을 참여 노드가 분산적으로 수행
* 탈중앙화된 장터
  * 신원 조회/ 평판 시스템 기반 P2P 장터를 구축
* 파생 상품과 가치 안정 통화
  * 금융 시스템의 핵심인 파생 상품 구현 및 외부 시세 참조를 통한 가치 안정 통화
* 신원 조회 / 평판 시스템
  * 인터넷의 도메인을 IP 주소와 연결하는 DNS 및 사용자 명의 등록 시스템 
* 분산형 파일 저장소
  * 유저 개개인이 남는 하드디스크 공간을 대여해주는 댓가로 소액의 보상을 지급



## Ethash

<img src="./images/ethash.png" alt="image-20211103162956109" style="zoom:50%;" />

* 이더리움은 이더해시(Ethash)라는 작업증명 알고리즘을 사용하여 채굴할 수 있다.
* 이더리움은 비트코인과 같은 작업증명(PoW) 방식의 합의 알고리즘을 사용하고 있고 있지만, 기존 비트코인의 SHA-256 방식을 사용하지 않고, Hashimoto/Dagger hybrid인 이더해시(Ethash) 방식을 사용한다.
  * Dagger 와 Hashimoto 알고리즘의 장점을 결합한 Dagger-Hashimoto 의 수정버전
* 기존의 작업증명(PoW) 방식에서는 중국의 비트메인 등 소수의 채굴업체들이 에이식(ASIC) 방식의 고성능 채굴기를 제작하고 거대한 마이닝풀을 구성하여 막강한 영향력을 행사할 수 있다.
  * 심지어 전체 해시파워의 과반수에 이르는 연산력을 보유하고, 이른바 51% 공격도 가능한 상황이었다.
* 이더리움이 채택한 이더해시 방식을 따를 경우, 에이식(ASIC) 채굴기를 사용한 채굴이 매우 어렵다. 
  * 이더리움을 채굴하려면, 채굴하기 전에 컴퓨터에서 대그(DAG) 작성이라는 프로세스를 수행해야 한다.
  * 해시값을 구하기 위해서는 논스뿐만 아니라 DAG의 데이터를 랜덤하게 읽어와야 한다.
* 컴퓨터 메모리상의 일정 양의 데이터를 읽은 후 이를 넌스와 함께 해시계산을 함으로써 메모리 IO 중심의 작업 증명
  * Memory Hard Computation
  * Memory Easy Validation
  * DAG에서 한번에 읽어오는 데이터는 128 바이트이므로 하나의 논스를 해시할 때에 (128 바이트 * 64) = 8KB의 메모리를 읽어오는 작업이 필수적이고, 따라서 연산력은 프로세서(CPU, GPU)의 속도보다 RAM의 속도에 큰 영향을 받는다.
* 약 12초에 하나의 블록을 생성하는 것이 알고리즘의 궁극적인 목표



**HASHIMOTO**

* CPU에 비해 상대적으로 느린 메모리(RAM)의 최대 읽기/쓰기 속도보다 빠르게 채굴을 수행할 수 없는 알고리즘



**DAGGER**

* DAG(Directed Acyclic Graph)를 사용하여 메모리 상으로 계산하기 어렵지만 검증하기 쉬운 알고리즘



## Ether

* 이더리움(Ethereum) 네트워크는 그 안에서 자체적으로 통용되는, ‘이더(Ether)’라는 화폐를 가지고 있다. 
* 이더는 여러가지 가상자산들간의 효율적인 교환을 가능하게 하는 매개물의 역할을 하며, 또한 트랜잭션 수수료를 지불하기 위한 방법을 제공한다.



**Ether와 Gas**

* 이더리움 월드 컴퓨터에서 계산 비용을 지급하기 위한 가스를 이더로만 살 수 있다.
* 이더는 트랜잭션과함께 보내야하고 가스 구매를 위한 허용 가능한 가격을 명시적으로 지정한다.
* 가스의 가격은 정해져있지 않다.
* 트랜잭션을 위해 가스가 구매되고, 계산을 수행하고, 사용 후 남은 가스는 발신자에게 반환된다.



## Ethereum

* 종종 월드 컴퓨터라고 불린다.
* 이더리움은 [스마트 컨트랙트](#contract)라는 프로그램을 실행하는 오픈 소스에 기반을 둔 전 세계에 걸쳐 탈중앙화된 컴퓨팅 인프라스트럭쳐이다
* 블록체인을 사용하여 시스템의 상태 변화를 동기화하고 저장하며, [이더](#ether)라고 하는 암호화폐를 이용하여 실행 자원 비용을 측정하고 제한한다.
* 개발자는 이더리움 플랫폼을 사용해서 경제적 기능들을 내장한 강력하면서도 탈중앙화된 애플리케이션을 개발할 수 있다.
* 이더리움 플랫폼은 고가용성, 감사 가능성, 투명성, 중립성을 제공하는 동시에 검열을 줄이거나 없애고, 거래상대방의 위험을 줄인다.
* 이러리움의 주된 목적은 디지털 화폐 지급 네트워크가 아니다
  * 이더의 주 목적은 월드 컴퓨터로서 이더리움 플랫폼 사용로를 지불하기 위한 유틸리티 화폐이다.



## EVM

* 이더리움 가상 머신이라고 하는 **에뮬레이트된 컴퓨터에서 스마트 컨트랙트라는 프로그램을 실행**한다.
* EVM은 싱글톤으로 전 세계에 걸친 **단일 인스턴스 컴퓨터인 것처럼 작동**한다.
* 각 노드들은 컨트랙트 실행을 확인하기 위해 EVM의 로컬 사본을 실행하고 이더리움 블록체인은 트랜잭션과 스마트 컨트랙트를 처리할 때 월드 컴퓨터의 변화하는 상태를 기록한다.



**emv의 특징**

* 튜링 완전 머신
  * 앨런 튜링이 고안한 개념으로, 수학적으로 어떠한 알고리즘이든 실행시킬 수 있는 머신(우리가 쓰는 일반적인 컴퓨터)
* 컴퓨터와 같은 구조
  * 코드와 저장소, 스택, 인자, 메모리 등 일반적인 컴퓨터가 갖는 구조를 그대로 가지고 있음
  * 스택 머신
    * 프로그램의 수행 과정에서 데이터가 스택이라는 자료구조를 활용하는 머신. (스택 아이템의 크기는 256비트, 총 크기는 1024)
  * 메모리
    * 256비트의 데이터가 배열로 저장된 형태로 영구적이 아닌 휘발성 메모리를 보유
  * 저장소
    * 키-값 형태의 데이터 저장소로써 데이터는 블록체인 위에 영속적으로 저장됨.
* GAS
  * 정지되지 않고 무한히 수행되는 프로그램(Halting Problem)을 방지하기 위해 수수료를 낸만큼만 EVM을 사용할 수 있음
* 바이트 코드
  * 스택 기반으로 실행될 수 있는 저수준의 기계어에 가까운 코드로써, EVM은 바이트 코드만을 수행함.



## Fallback Function

* [트랜잭션](#transation)에 데이터가 없거나 선언된 함수 이름이 없는 경우 호출되는 [컨트랙트](#contract)의 기본 함수입니다.



## Gas

* 계산의 기본 단위
  * EVM의 각 명령어는 가스 단위로 미리 정해진 비용이 있다.
  * 거래 데이터의 1바이트당 5가스의 수수료가 발생한다. 
* 수수료 시스템의 의도는 어떤 공격자가 계산, 밴드위스, 저장소 등을 포함하여 그들이 소비하는 모든 리소스에 비례하여 강제로 수수료를 지불하게 하는데 있다
* 이더를 거래할 때도 수수료가 요구된다. 이는 실물처럼 그냥 주고받는 것이 아니라 데이터를 옮기는 것이기 때문에 계산이 필요하고 여기서 계산을 위한 노동의 보상으로 발생하는 것이 가스다.
* 데이터를 옮기기 위해서는 채굴자들의 연산 작업이 필요한데, 채굴자들이 한 계산에 대한 보상으로 가스를 제공한다.
* **가스는 네트워크의 과부하를 막으며, 이더리움 플랫폼이 계속 운영되도록 하는 인센티브 역할을 한다**



### Gas Price

* **하나의 연산 단계에 부여할 이더의 양(WEI 단위).**
* 트랜잭션 생성자는 원하는 가스 가격을 지정할 수 있다.
  * 예를 들어 ‘가스 당 3Gwei를 지불할 용의가 있다.’라고 설정했을 때, 트랜잭션이 1,000,000가스를 소비하고 가스 가격을 3Gwei로 설정하면 해당 트랜잭션에 대한 수수료로 3,000,000Gwei를 지불하게 된다.
* 대부분의 채굴자들은 가스 가격의 내림차순으로 트랜잭션을 분류하고 가스 가격이 높은 트랜잭션을 선택하여 블록에 포함시키기 때문에 설정한 가스 가격이 높을수록 트랜잭션은 더 빨리 처리된다.
* 가격을 낮게 책정해도 결국 트랜잭션이 블록에 포함되기는 하지만 그 대기 시간이 상당히 길어질 가능성도 있다.
* 가스 가격은 일반 사람들에 의하여 무작위로 책정되지는 않고 가스 가격을 측정해주는 사이트가 있다. 
  * 이더리움 가스스테이션이라는 사이트인데, 이곳에서 적당한 가스 가격을 선택할 수 있다. 사용되는 가스의 평균값이라고 보면 된다. 
  * 빠른 처리를 원할 경우 여기 나온 금액보다 높은 가격을 측정하면 된다.



### Gas Limit

* **해당 거래가 수행될 때 사용할 수 있는 최대 연산 단계의 수**
* **즉 하나의 거래에서 사용될 수 있는 최대 가스 양은 Gas Limit * Gas Price 이고 이 중 사용되지 않은 가스는 반환된다.**
* 가스 한도는 작업 중단 시점을 보장함으로써 무제한으로 이더를 사용하는 것을 방지할 수 있다.
* 사용자는 트랜잭션을 실행하기 위해 사용할 가스의 최대 금액을 나타내는 가스 한도(Gas Limit)를 설정한다.
* 가스 한도는 요청하는 작업량의 추측이다. 하지만 추측은 쉬운 일이 아니다.
  * 일반적으로 21,000가스의 한도는 대부분의 거래를 만족한다고 알려져 있다.
* 한도가 낮으면 작업이 완료되지 않고 거래는 실패하며 그 시점까지 사용된 이더가 손실된다.
* 한도를 너무 높게 설정하여 한도 전에 작업이 끝나더라도 작업에 사용되지 않은 모든 이더는 다시 되돌려 받을 수 있다



**Gas Limit 측정**

* 트랜잭션은 크게 2가지 종류로 단순한 이더리움 송금(transactions)과 Contract를 실행시키는 트랜잭션(contract internal transactions)이 있다. 
* EOA간의 Value transfer(Standard transaction)는 21,000개의 가스가 소모됨
* Contract 실행은 코드의 복잡성에 따라 천차만별이다. 
  * 어떻게 이걸 예측해서 Gas Limit을 결정할 수 있을까? 
  * 답은 간단하게도 실제로 계산을 해보는 것이다. 
  * 명령어별로 이미 Gas Fee는 공개가 되어있으며 개발자는 자신의 Solidity 코드가 어느 정도의 Gas가 들지 예측할 수 있다.



## GHOST Protocol

* Greedy Heaviest Observed Subtree
* 다중 체인 방지 프로토콜
  * [스테일 블록](#stale-block) 문제 해결
  * 빠른 블록 생성 시 스테일 블록이 많이 생성되고 그로 인해 보안성이 저하된다.
* GHOST 는 어느 체인이 “가장 긴(longest)”것인지 계산할 때 스테일 블록도 포함으로써 네트워크 보안 손실이라는 문제를 해결한다.
  * 어느 블록이 가장 큰 전체 작업증명을 가지고 있는지 계산할 때 그 블록의 모블록과 그 조상뿐만 아니라, 그 블록의 삼촌까지도 더한다는 것이다
  * 스테일 블록도 기본 보상의 87.5%를 받게 되며, 그 스테일 블록을 포함하고 있는 사촌이 나머지 12.5%를 받는다.
  * 하지만 수수료는 삼촌들에게는 주어지지 않는다.
* GHOST 프로토콜은 가장 최신의 블록넘버를 가진 경로(계산을 가장 많이 수행한 경로)를 선택하도록 함
* 스테일 블록에 대한 보상을 지급함으로써 스테일 블록을 메인체인에 포함하여 Difficulty의 상승을 유도함



> 삼촌 블록
> 현재의 블록과 조부모 블록을 공유하는 블록으로써, 최대 6대 위의 블록까지만, 최대 2개의 블록만 삼촌 블록으로 기록될 수 있다.
> 삼촌 블록은 유효한 블록 헤더를 가지고 있어야 하며 유효한 블록일 필요는 없다. 삼촌 블록의 채굴자는 기본 블록 보상의 93.75%를 지급받고 삼촌 블록을 기록한 블록의 채굴자는 기본 보상에 3.125%를 추가로 지급받는다.



## Merkle-Patricia Tree

<img src="./images/merkle.png" alt="image-20211103164512521" style="zoom:50%;" />

* 머클 트리와의 차이점
  * 머클 트리를 수정한 트리로써, 각 노드가 하나의 해시값을 가지고 있는 것이 아니라 해시값 중 한 글자만 가지고 있는 트리. 트리를 탐색함으로써 전체 해시값을 얻게 된다.



**머클 트리의 탐색 방법**

* HK에 해당하는 거래를 검색하기 위해서는 HL, HIJ, HMNOP, HABCDEFGH가 있으면 되고 이를 머클 경로라고 한다.



## Message(INTERNAL TRANSACTION)

* [컨트랙트](#contract)는 다른 컨트랙트으로 메시지를 보낼 수 있다. 
* 메시지는 [트랜잭션](#transaction)과 다르게 별도 저장할 필요가 없으며 이더리움 실행 환경에만 존재하는 가상 객체입니다.
* [컨트랙트](#contract)가 `CALL` opcode를 실행할 때 메시지가 생성된다.



**Message 구성요소**

* 메시지 발신인
* 메시지 수신인
  * CA 또는 EOA

* ether 양
* Data(데이터)
* STARTGAS



**Transaction과 비교**

* 본질적으로 메시지는 외부 행위자가 아닌 **컨트랙트에 의해 생산된다는 점**을 제외하면 트랜잭션과 유사하다. 
* 트랜잭션과 마찬가지로 메시지는 **수신자 계정으로 코드를 실행되게한다.** 
* 그러므로 계약들은 외부 행위자들이 할 수 있는 것과 정확히 같은 방식으로 **다른 계약들과 관계를 맺을 수 있다.**



## PoW

* 작업증명(PoW, Proof of Work)이란 목표값 이하의 해시를 찾는 과정을 무수히 반복함으로써 해당 작업에 참여했음을 증명하는 방식의 합의 알고리즘이다.
* 작업증명에서는, 분산 합의의 결론을 도출하는 과정에서 더 많은 연산 작업을 수행한 주체일수록 결과를 결정할 수 있는 더 큰 영향력을 보유하게 된다.



## PoS

* 지분증명(Proof of Stake)
* 지분증명이란 해당 암호화폐를 보유하고 있는 지분율에 비례하여 의사결정 권한을 주는 합의 알고리즘이다.
  * 해당 암호화폐를 보유한 지분에 따라 채굴에 성공할 확률이 결정된다.
* 지분증명에서는, 분산 합의의 결론을 도출하는 과정에서 더 많은 지분을 보유한 주체일수록 결과를 결정할 수 있는 더 큰 영향력을 보유하게 된다.
* 채굴 과정이 필요 없다
* 지분증명은 작업증명(PoW)의 문제점으로 거론되는 막대한 에너지 및 리소스 소모를 해결한다.
* 별도의 채굴기가 필요 없이 코인을 보유하고 있으면 기본적인 자격이 충족된다.

**장점**

* 지분증명방식의 가장 많이 알려진 장점은 작업증명방식과 대조적으로 에너지 소모가 큰 프로세스가 없다는 점이다.
* 작업증명방식의 문제점 중 하나가 마이너들과 암호화폐 보유자들의 이해관계가 일치하지 않을 수도 있다는 점이다. 또한 다른 문제점은 장기적 관점에서 해시레이트(hashrate)를 리스(lease) 할 수 있다는 점이다. 지분증명방식은 이와 다르게 합의 대리인을 직접적으로 암호화폐에 투자하게 만들고 그에 따라 투자자와 합의 대리인의 이해관계가 같아지게 된다.
* 지분증명방식 기반 시스템의 또 다른 주요 장점은 작업증명방식의 마이닝이 가진 중앙집중식 특징으로 제거한다. 그로 인해 잠재적으로 더욱 탈중앙화 될 가능성이 있다는 것이다.

**단점**

* 지분증명방식 시스템은 체인 선택에 대한 해결책만을 제시했다. 그 외 나머지 문제점들에 대한 해답은 제시하지 못하였다.
* 이 시스템은 암호화폐 보유량에 비례하여 신규 자금을 배당한다. 그말은 소수의 사람들에게 자금이 집중될 수 있다는 것을 의미한다. 이러한 점을 보고 보상 시스템이 쓸모없고 인센티브를 전혀 제공하지 못하다고 비춰질 수 있다.
* 지분증명방식은 지분을 받기 위해서는 인터넷에 연결된 시스템에 의해 검증된 메시지가 필요하다. 결국 지분 보유자들은 해커에 의한 자금 도난 위험이 높은 핫 월렛을 갖고 있어야 한다. 프라이빗 키를 부여하여 단점을 보완하려고 했지만 그것은 완전한 해결책이 되지 못한다.
* 코인을 얻기위해 코인을 사용하지 않고 보유하려는 성향 때문에 코인의 유통성이 저하된다.



## Private key

* 계정 주소는 Private key에서 파생된다.
  * 공개키는 개인키에서 파생된다.
  * 외부 소유 계정의 이더리움 주소는 공개키-개인키 쌍의 공개키 부분에서 생성된다.
* 공개키는 은행 계좌번호와 개인키는 PIN(개인 식별 번호)와 유사하다
* 개인키는 대부분 암호화된 형태로 특수 파일에 저장하고 이더리움 지갑 소프트웨어로 관리한다
* 외부 소유 계정의 이더리움 주소는 공개키-개인키 쌍의 공개키 부분에서 생성된다.



## Public Key

* 개인 키에서 단방향 함수를 통해 파생된 숫자이다
* 공개키는 네트워크에 공개되어 대응되는 개인 키로 작성된 디지털 서명을 확인하는 데 누구나 사용할 수 있습니다.



## Solidity

* 프로그래밍 언어를 저차원(Low-Level)과 고차원으로 구분했을 때 비트코인 스크립트 언어와 달리 고차원 언어.
* C++, Python, 자바스크립트 등 기존에 널리 사용되고 있던 언어에 영향을 받았기에 어렵지 않게 학습이 가능.
* 스마트 계약 작성을 위해 탄생한 언어로써 언어의 모든 요소가 스마트 계약을 쉽게 작성할 수 있도록 설계됨.
* 튜링 완전성으로 인해 표현의 제약없이 자유롭게 어떠한 형태의 경제 활동이든 프로그래밍이 가능.



## State

* [EVM](#evm) 코드의 공식적인 실행 모델은 놀라울 정도로 간단하다. 
* 이더리움 가상 머신이 실행되는 동안 상태는 tuple(block_state, transaction, message, code, memory, stack, pc, gas)로 정의된다.
* 각 명령어는 튜플에 어떻게 영향을 미치는지에 대한 자체 정의가 있다. 
  * ADD는 스택에서 두 개의 항목을 pop하여 합계를 push하고 가스를 1만큼 줄이고 pc를 1 증가시킨다.
  * SSTORE 는 스택에서 두 개의 아이템을 꺼내 이 아이템의 첫 번째 값이 가리키는 컨트랙트 저장소 인덱스에 두 번째 아이템을 넣는다.
* 세계 상태(World State: 모든 계정들의 상태의 전체 집합)는 Merkle-Particia 트리의 형태로 각 노드에 저장되고 각 블록에는 세계 상태 트리의 최상위 노드만 저장한다.



**block_state**

* block_state는 글로벌 state이며 모든 계정과 잔액 및 스토리지를 포함한다.

**PC**

* 현재 수행되는 instruction을 가리킴



### State Tree

* 계정 상태
  * Nonce, Balance, Codehash, StorageRoot로 이루어져 있으며 특정 시점에서 각 계정의 상태를 나타낸다.
* 세계 상태
  * 모든 계정 상태의 집합으로써 계정의 주소-계정 상태의 쌍으로써 트리의 형태(Merkle-Patricia Tree) 로 표현된다.



## State Transition Function

![ether-state-transition](https://ethereum.org/static/2c0e5e27e397f4ac6b88082fd28d072f/00e09/ether-state-transition.png)

이더리움 상태 변환 함수 APPLY(S,TX) -> S'는 다음과 같이 정의할 수 있다.

1. 트랜잭션이 제대로 구성되어 있는지 확인합니다. 
   * 서명이 유효한지 확인
   * 발신자 계정의 nonce와 트랜잭션의 nonce가 같은지 확인
   * 같지 않으면 오류를 반환
2. 거래 수수료를 STARTGAS * GASPRICE로 계산하고 서명에서 발송 주소를 결정합니다. 
   * 발신자의 계정 잔액에서 수수료를 뺀다.
   * 발신자의 nonce를 증가시킨다.
   * 사용할 잔액이 부족하면 오류를 반환
3. GAS = STARTGAS를 초기화하고 바이트당 일정량의 가스를 차감하여 트랜잭션의 바이트값을 지불합니다.
4. value를 발신자의 계정에서 수신자의 계정으로 이동시킨다.
   * 만약 수신자의 계정이 존재하지 않는다면 생성한다.
   * 만약 수신자가 [컨트랙트 계정](#contract account)이라면 컨트랙트의 코드를 끝까지 또는 gas 가 모두 소모될 때 까지 수행한다.
   * 만약 수신자가 컨트랙트가 아니라면
     * 총 거래 수수료는 제공된 가스 가격에 거래 길이를 바이트로 곱한 것과 같다.
5. 발신자의 잔액 부족으로 value전송이 실패하거나 가스 부족으로 code 실행이 실패하면
   * 수수료 지불을 제외한 모든 상태를 복구한다.
   * 그리고 마이너의 계정에 수수료를 준다.
6. 실패하지 않으면 남은 가스 사용료는 모두 발신자에게 환불하고, 소비한 가스 사용료는 마이너에게 보낸다.

> 만약 거래의 수신자가 contract가 아니라면, 총 거래 수수료는 제공된 가스 가격에 거래 길이를 바이트로 곱한 것과 같을 것이고, 거래와 함께 보내진 데이터는 관련이 없을 것이다.



## Transaction

![ether-state-transition](https://ethereum.org/static/2c0e5e27e397f4ac6b88082fd28d072f/00e09/ether-state-transition.png)

* 트랜잭션은 [EOA](#eoa)에서 보낼 메시지를 저장하는 서명된 데이터 패키지를 말한다.
  * [컨트랙트](#contract)는 트랜잭션의 발신자가 될 수 없다.
* 이더리움 네트워크에 위해 전송되고 이더리움 블록체인에 기록된다.
* 트랜잭션은 [EVM](#evm)에서 상태 변경을 유발하거나 컨트랙트를 실행할 수 있는 유일한 방법이다.
* 컨트랙트는 독자적으로 실행되지 않는다 모든 것이 트랜잭션으로부터 시작된다.
* 두 가지 유형의 트랜잭션이 있다
  * 코드를 가진 새로운 계정을 생성하는 트랜잭션(컨트랙트 생성 트랜잭션)
  * 메시지 호출을 발생시키는 트랜잭션



### Transaction Fields

**공통 필드**

* nonce(논스)
  * 발신자 주소에서 보낸 트랜잭션의 수
* gasPrice 와 gasLimit
  * gasPrice : 발신자가 지급하는 가스의 가격(웨이)
  * gasLimit: 이 트랜잭션을 위해 구입할 가스의 최대량
  * [gas](#gas)
* to(수신자)
  * 목적지 이더리움 주소(160비트)
  * 컨트랙트 생성 시 공란
* value(값)
  * 목적지에 보낼 이더의 양
  * 컨트랙트 생성의 경우 새로 생성되는 컨트랙트 계정의 잔액에 예치된다.
* v, r, s
  * EOA의 ECDSA 디지털 서명의 세 가지 구성요소
  * 트랜잭션의 서명에 해당하는 값들이며 트랜잭션의 발신자를 결정하는 데 사용됩니다.



**message call transaction 필드**

* data
  * 가변 길이 바이너리 데이터 페이로드
  * Message call의 입력 Data
  * 데이터 필드는 기본적으로 아무 기능이 없다.
  * EVM에는 계약이 이 데이터에 액세스할 수 있는 opcode가 있다
  * 사용 예시
    * 계약이 블록체인 도메인 등록 서비스로 작동하는 경우, 
    * 전송되는 데이터를 두 개의 "필드"를 포함하는 것으로 해석할 수 있다
    * 계약은 첫번째 필드로 등록할 도메인과 두 번째 필드로 등록할 IP 주소로 읽고 이를 적절하게 storage에 보관할 수 있다.



**contract creation transaction 필드**

* init



## Turing Complete

* 튜링완전(Turing-Complete)는 어떤 프로그래밍 언어나 추상 머신이 튜링머신과 동일한 계산 능력으로 문제를 풀 수 있다는 의미이다.
* 튜링머신(Turing Machine)
  * 추상적인 수학 개념상의 기계이다. 
  * 알고리즘 구현 언이인 튜링완전언어로 구현되며 무한한 저장공간만 있다면 이 세상의 모든 문제를 풀 수 있는 기계를 만드는 것이 가능한데, 그것을 튜링머신이라고 한다.



## Wallet

* 이더리움 계정을 관리하는데 도움을 주는 소프트웨어 애플리케이션
* 지갑은 사용자의 키를 보유하고 사용자를 대신하여 트랜잭션을 생성하고 브로드캐스팅한다.

