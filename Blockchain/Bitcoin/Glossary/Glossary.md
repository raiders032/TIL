# Address

* 비트코인 주소는 수학적으로 공개 키에 해당하며 다음과 같이 보입니다.
* 예시) 1PHYrmdJ22MKbJevpb3MBNpVckjZHt89hz
* 각각의 사용자가 많은 주소를 가질 수 있다

# [Block](https://en.bitcoin.it/wiki/Block)

* 트랜잭션 데이터가 영구 저장되는 공간을 의미한다.



## **Block의 구조**

* Blocksize: 바이트
* Blockheader: 6가지로 구성
* transactions: Transaction 목록



## Block header

* Version: Block version number(4바이트)
* prev_block: 이전 블록의 해시 값(32바이트)
* merkle_root: 해당 블록에 포함된 모든 transactions의 해시인 머클 트리 콜렌션에 대한 참조(32바이트)
* timestamp: 이 블록을 만들 때의 타임스탬프 기록(4바이트)
* bits: 이 블록에 사용되고 있는 난이도(4바이트)
* nonce: 이 블록을 생성하는 데 사용되는 nonce는 헤더의 변형을 허용하고 다양한 해시를 계산하는 데 사용됩니다.(4바이트)
* 총 80바이트로, 1년 동안 발생하는 52,560개의 블록 헤더 용량이 4MB 정도



# Block Chain

* 블록체인은 비트코인 프로토콜 기반의 시스템에 참여하는 모든 노드가 공유하는 트랜잭션 데이터베이스이다. 
* 블록체인의 모든 Transaction이 공개되어 있다
  * 이 정보로 어느 시점에서나 각 주소에 얼마만큼의 코인이있는지 알 수 있다.
* 모든 블록에는 이전 블록의 해시가 포함되어 있습니다. 
  * 이는 제네시스 블록에서 현재 블록까지 블록을 체인처럼 연결하는 효과가 있다.
  * 이러한 특성 때문에 한 블록을 수정하기가 어렵다 블록이 체인처럼 연결되어 있기 때문에 해당 블록 이후의 블록도 재생성해야된다.
  * 따라서 시간이 지남에 따라 블록이 추가될 것이고 
  * 이러한 특성들이 Transaction을 되돌릴 수 없게 만든다.

# Coinbase

* 코인베이스는 모든 블록의 첫 번째 거래에 주어진 특별한 이름이다. 이를 `Generation Transactions`라고도 한다.
* POW 작업에 대해 마이너를 보상하기 위해, 모든 블록의 마이너는 인풋없이 자신에게 25 BTC를 주는 트랜잭션을 블록 맨앞에 포함시킨다.
* BTC가 발행되는 유일한 메커니즘이다
* genesis 상태에는 coin이 전혀 존재하지 않았다

# [Confirmation](https://en.bitcoin.it/wiki/Confirmation)

* 트랜잭션이 네트워크로 브로드캐스트된 후 블록에 포함되어 네트워크에 공표된다. 
  * 이 상태를 Transaction이 1블록 깊이에서 채굴되었다고 한다.
  * 이후 블록이 추가될 때마다 블록 깊이가 1씩 증가한다.
  * 이중 지출로부터 안전하기 위해, Transaction이 일정 블록 깊이가 될 때까지 Confirmation된 것으로 간주해서는 안 된다.
* Confirmation 되지않은 트랜잭션은 만료되지 않는다.
* 6개의 블록이 Transaction을 Confirmation할 때까지 거래를 "Unconfirmed"로 표시한다

# Difficulty

* `Difficulty`는 주어진 `Target` 아래의 해시를 찾는 것이 얼마나 어려운지를 나타내는 척도이다.
* 비트코인 네트워크는 글로벌한 `Difficulty` 를 공유한다.
* 유효한 블록은 해시 값이  `Target` 보다 작아야 한다.
* 2016 블록마다 `Difficulty`가 변한다.

# Double-Spending

* 다른 트랜잭션에서 이미 사용된 코인을 또 다시 사용하는 것



# Full Node

* 풀노드(full node)는 블록체인의 모든 내역을 저장하는 노드이다.
  * 제네시스 블록부터 시작해서 현재 블록까지 모든 블록체인 정보를 수집, 저장한다
* PC에 모든 내역이 저장되어 있기 때문에 스스로 거래 검증이 가능하다
* 모든 내용을 저장하기 위해 소요되는 시간이 길고 큰 용량이 필요하다는 단점이 있다.
  * 이런 풀노드의 단점을 해결하기 위해 나온 것이 [라이트노드](#light-node)이다.
* 방대한 양의 데이터를 다운받고 검증하는 시스템을 갖춘 만큼, 방대한 양의 데이터를 소화할 수 있는 대규모 채굴업 관련 종사자들에게 필요한 기술이라고 할 수 있다
* 풀노드는 블록체인 데이터를 동기화하기 위헤 메모리를 사용한다.



**Full Node의 역할**

1. 거래가 진행될 때 각 거래자들의 계좌정보, 잔액 등의 정보확인을 통해 유효한 거래인지 확인한다.
2. 전체 기록을 다 가지고 있기에, 새로운 블록이 추가될 때 조작이 없는지 이전 거래와 내역이 일치하는지 등을 누구의 도움 없이 모든 거래에 대한 검증이 가능하다.
3. 새로운 블록이 생성된 후 채굴을 성공한 채굴자에게 올바르게 보상이 제공되었는지 확인한다.
4. 블록에서 이중 지불이 발생하지 않았는지를 확인한다.
5. 본인이 가진 기록정보를 다른 노드들에게 전달하는 일을한다.

# [Hash](https://en.bitcoin.it/wiki/Hash)

* 간략히 말하면 요약을 하는 것 일정한 길이의 결과물이 나온다
* 해시 알고리즘은 임의의 많은 양의 데이터를 고정 길이의 값으로로 변환하는 것을 말한다.
* 동일한 해시가 항상 동일한 데이터에서 발생하지만, 1비트의 데이터를 수정해도 해시가 변경됩니다. 
* 모든 컴퓨터 데이터와 마찬가지로 해시는 큰 숫자이며 일반적으로 16진수로 작성된다.
* 비트코인은 SHA-256 해시 알고리즘을 사용하여 예측 가능한 CPU의 노력을 요구하는 방식으로 검증 가능한 난수들을 생성한다. 
* 현재 `Target`보다 작은 값의 SHA-256 해시를 생성하면 블록이 해결되고 코인을 획득할 수 있다



# [Irreversible Transactions](https://en.bitcoin.it/wiki/Irreversible_Transactions)

* 올바르게 사용한다면 블록체인의 기본 계층 Transaction는 되돌릴 수 없고 최종적이다. 
* Block Chain, Mining, POW, Difficulty 등의 비트코인 시스템은 수정할 수 없는 transaction의 역사를 만들기 위해 존재한다고 할 수 있다
* 전자 화폐에 관한 문헌에서 이 속성은 종종 "이중 지출 문제 해결"로 언급되었다. 
* 이중지출은 한 번 이상 성공적으로 돈을 쓴 결과입니다.
* 비트코인 이용자들은 블록체인에서 결제를 받을 때 `Confirmation`을 기다리며 이중 지출 사기로부터 자신을 보호하는데, `Confirmation` 횟수가 늘어날수록 거래는 더욱 수정할 수 없게 된다.



# Light node

* 라이트노드는 블록체인 거래내역 중 일종의 핵심본만 저장하는 노드이다. 
* 모든 블록 정보를 가지고 있지 않고, 필요한 부분만 저장한다는 특징이 있다.
  *  즉 블록헤더에 있는 중요한 데이터만 보유하고 있다.
* 모든 블록정보를 가지고 있지 않기 때문에 어떤 새로운 거래 정보를 수신받았을 경우 이 거래가 정상적인지 검증할 수 없다.
* 라이트노드는 블록체인에 참여하여 거래를 수행하는 노드로, 풀노드에 거래 데이터를 요청하여 개별 거래를 검증하는 기능을 수행한다.
  * [SPV](#SPV)

# [Majority attack](https://en.bitcoin.it/wiki/Majority_attack)

* Majority attack(보통 51% 공격 또는 50% 공격)은 네트워크에 대한 공격이다. 
* 공격자가 자신의 체인을 가장 길게 만들기 위해선 나머지 노드들의 컴퓨팅 파워를 합친 것 보다 더 많은 컴퓨팅 파워가 필요하다
* 이러한 공격을 Majority attack이라 한다.

# Merkle Tree

![spv-bitcoin](https://ethereum.org/static/47aecc91895df6cd1b3e8089aa7e9a7c/e4900/spv-bitcoin.png)

* 머클트리(Merkle Tree)는 블록에 포함된 거래 내역을 요약한 것이다.
* Merkle 트리는 이진 트리의 일종이다.
  * 머클 트리는 많은 노드로 구성된다
  * 리프 노드에는 저장하고자 하는 데이터가 들어있다.
  * 중간 노드는 두 자식의 해시이다.
  * 루트 노드 또한 두 자식의 해시이다.
  * 이 과정을 통해 다수의 데이터를 하나로 묶어 용량을 절약할 수 있다.
  * SHA256 해시를 사용

**용도**

* 머클트리에서는 모든 거래내역들을 해시화한 **머클루트를 통해 거래내역의 변동여부를 쉽게 확인**할 수 있다
  * 머클트리 자체가 해시로 이루어진만큼 하나의 트랜잭션 혹은 블록 내 필드값이 변조될 경우 머클루트 해시 값이 변조되는 쇄도 효과(avalanche effect)가 발생한다. 
* 머클루트를 헤더에 담아 트랜잭션의 유효성을 보장한다.
* 머클 경로(Merkle path)를 제공받아 **특정한 트랜잭션이 블록에 유효하게 있는 효율적인 검사가 가능**하다. 
* 머클트리는 모든 정보를 압축하여 간단하게 표현한 데이터로서 머클트리를 통해 데이터의 간편하고 확실한 인증이 가능하다



**구성요소**

* 머클루트 
  * 블록이 보유하고 있는 거래 내역들의 해시값을 가장 가까운 거래내역끼리 쌍을 지어 해시화하고 쌍을 지을 수 없을 때까지 이 과정을 반복했을 때 얻게 되는 값이다. 
  * 이는 블록에 저장되어 있는 모든 거래의 요약본으로 해당 블록에 포함된 거래로부터 생성된 머클트리의 루트에 대한 해시정보가 담겨있다. 
  * 아무리가 거래가 많이 발생하여도 하나로 압축된 머클 루트의 용량은 항상 32 바이트이다
* 머클 경로 
  * 머클 경로(Merkle path)는 어떤 거래의 진위를 따질 때 이를 검증하는 과정이다. 
  * 머클루트가 주어진다면, 좀 더 쉽게 검증이 가능하다.

# Mining

* 마이닝의 주된 목적은 거래의 역사를 어느 한 실체가든 전산적으로 수정할 수 없는 방식으로 설정하는 것이다. 블록체인을 다운로드하고 검증함으로써 비트코인 노드들은 비트코인의 이벤트 순서에 대한 합의에 도달할 수 있다.
* 거래 내역을 담은 블록을 만드는 과정
* 블록을 만들기 위해서 어려운 수학 문제를 풀어야한다.
  * 한 10분 정도 걸리게 문제의 난이도는 자동적으로 조절됨
* 유저가 문제의 해답을 찾으면 해답을 네트워크에 알린다.
  * 찾은 해답과 몇가지 정보를 묶어 패키지화 한것이 블록이다
* 블록을 만든다는 것은 해당 블록이 진짜임을 증명하는 것
  * 해당 블록에 포함된 거래내역들이 진짜라는 것
  * 이를 합의 메커니즘이라고 한다.
* 대표적인 합의 메커니즘
  * 작업 증명
  * 지분 증명

**보상**

* 올바른 블록을 가장 먼저 만들게되면 신규 비트코인이 보상으로 지급된다.
* 시작 당시 50개 대략 4년 마다 반감된다.
* 비트코인 매장량을 21백만개로 정해져있다
* 2140년 정도에 채굴완료 예정
* 그 이후에는 블록 생성 대가로 수수료만 받는다
  * 거래에는 수수료가 붙는데 그것을 블록을 만드는 사람이 가져가는 것으로 동기부여한다.

# POW

* 블록을 만들기 위해 푸는 어려운 수학 문제의 해답을 찾는 것을 Proof of work라고 한다.
* 해답을 찾기는 어렵지만 답이 진실인지 확인하는 것은 쉽다.

* 



# **공개키 암호 시스템 주요 용도**

* 암호화: 퍼블릭 키로 암호화 프라이빗 키로 복호화
  * A가 B에서 암호화된 문서를 보내고 싶다
  * A가 문서를 B의 공개키로 암호화해서 보낸다.
  * B는 문서를 받아서 자신의 비밀키로 복호화 한다. 즉 B만 열어볼 수 있다.
* 전자서명: 프라이빗 키로 암호화 퍼블릭 키로 복호화
  * A가 해당 문서를 자신이 작성했음을 증명하고 싶다
  * A가 문서를 자신의 비밀키로 암호화
  * 누구나 A의 공개키로 검증 가능

* 



# Target

* Target은 모든 비트코인 클라이언트가 공유하는 256비트 숫자(아주 큰 숫자)입니다. 
* 블록 헤더의 SHA-256 해시는 블록이 네트워크에서 허용되려면 현재 대상보다 작거나 같아야 합니다. 
* Target이 낮을수록 블록 생성이 어려워진다.

# SPV

* SPV(Simple Payment Verification)
* SPV는 모든 블록체인을 다운로드 하지 않고 거래를 검증하는 간이 결제 확인 방법이다
* [라이트노드](#light-node)는 개별 거래에 대한 트랜잭션을 확인하기 위한 SPV(Simple Payment Verify, 단순 지불 검증)를 사용한다.
* SPV는 라이트노드에서 거래를 검증하기 위해 풀노드에게 블록정보를 요청하여 머클트리를 통해 이 거래가 검증된 거래인지를 확인하는 방법이다.

**문제점**

* SPV는 풀 노드들에 정보를 요청해야만 거래를 진행할 수 있기 때문에 풀 노드에 대한 정보의 의존도가 높다. 
* 풀 노드의 경우 처음부터 블록체인을 저장해왔고 최종적으로 돈이 들어 있는 계좌(UTXO)를 블록체인이 아닌 데이터베이스에 저장하기 때문에 더 빠른 속도로 처음부터 자신의 잔고를 확인할 수 있지만, SPV의 경우 다른 풀 노드에 의지하기 때문에 처음부터 제대로 된 정보를 주느냐가 문제이다. 
* 악의적 노드가 끼어들게 되면 SPV로써는 구분할 수 없기 때문에 큰 문제로 이어질 수 있으며 다른 노드들이 거래를 취소를 시켜버림으로써 거래지연이 발생하게 된다

# Transaction

* Transaction은 네트워크로 브로드캐스트되어 블록으로 수집되는 비트코인 가치를 전송하는 것입니다. 
* 트랜잭션은 일반적으로 이전 트랜잭션 출력을 새로운 트랜잭션 입력으로 참조하고 모든 입력 비트코인 값을 새로운 출력으로 전용합니다. 
* 트랜잭션은 암호화되지 않으므로 블록으로 수집된 모든 트랜잭션을 검색하고 볼 수 있습니다. 
* 일단 Transaction이 충분한 Confirmation을 받게 되면, Transaction은 되돌릴 수 없는 것으로 간주될 수 있다.
* 모든 트랜잭션는 해시를 가지고있다.

# Transaction expiration

* Transaction이 만료되는 것은 많은 사람들이 하는 흔한 오해이다. 
* 비트코인 Transaction은 한 번 생성되면 절대 자동으로 만료되지 않는다. 
* 이론적으로, 거래가 생성되어 몇 년 동안 0 확인에 갇혀 있다가 갑자기 확인될 수 있다



참고

* http://wiki.hash.kr/index.php/%EB%8C%80%EB%AC%B8