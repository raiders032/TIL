## 연관관계가 필요한 이유



## 연관관계 매핑시 고려사항 3가지

* 다중성
* 단방향, 양방향
* 연관관계의 주인



## 다중성

### @ManyToOne

* 다대일
* 가장 많이 사용하는 연관관계이다

| 속성         | 설명                                                         | 기본값          |
| ------------ | ------------------------------------------------------------ | --------------- |
| optional     | false로 설정하면 연관된 엔티티가 항상 있어야 한다.           | TRUE            |
| fetch        | 글로벌 페치 전략을 설정한다.                                 | FetchType.EAGER |
| cascade      | 영속성 전이 기능을 사용한다.                                 |                 |
| targetEntity | 연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거 의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타 입 정보를 알 수 있다. |                 |



### @OneToMany

* 일대다
* 일대다 단방향 매핑의 단점
  * 엔티티가 관리하는 외래 키가 다른 테이블에 있다
  * 연관관계 관리를 위해 추가로 UPDATE SQL 실행
* 일대다 단방향 매핑보다는 **다대일 양방향 매핑을 사용**하자

| 속성         | 설명                                                         | 기본값         |
| ------------ | ------------------------------------------------------------ | -------------- |
| mappedBy     | 연관관계의 주인 필드를 선택한다.                             |                |
| fetch        | 글로벌 페치 전략을 설정한다.                                 | FetchType.LAZY |
| cascade      | 영속성 전이 기능을 사용한다.                                 |                |
| targetEntity | 연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거 의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타 입 정보를 알 수 있다. |                |



### @OneToOne

* 일대일 
* 주테이블 또는 대상 테이블 중 하나에 외래키를 설정한다.
* 다대일 양방향 매핑 처럼 **외래 키가 있는 곳이 연관관계의 주인**이다
  * 주인이 아닌 곳은 mappedBy를 적용한다.



### @ManyToMany

* 다대다
* 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.
* 연결 테이블을 사용해서 일대다, 다대일 관계로 풀어낸다.
* `@JoinTable`로 연결 테이블을 지정한다.
* **실무에서는 사용하지 않는다.**
  * 연결 테이블용 엔티티 추가해서 다대다 관계를 일대다, 다대일 관계로 풀어낸다.



## 단방향 연관관계

### @JoinColumn

* 외래 키를 매핑할 때 사용한다.



## 양방향 연관관계와 연관관계의 주인

양방향 연관관계

* 단방향 매핑만으로도 이미 연관관계 매핑은 완료된다. 따라서 양방향 연관관계가 필수적이지 않다면 단방향 매핑으로 끝낸다.
  * JPQL에서 역방향으로 탐색할 일이 발생한다면 양방향 연관관계를 고려해보자
  * 테이블에 영향을 주지 않기 때문에 양방향 매핑은 필요할 때 추가한다.
* 양방향 매핑을 통해 반대 방향으로 조회(객체 그래프 탐색)가 가능하다.

객체의 양방향 관계

* 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단 뱡향 관계 2개다.
* 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.

테이블의 양방향 연관관계

* 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리한다.

연관관계의 주인(Owner)

* 객체의 두 관계중 하나를 연관관계의 주인으로 지정해야 한다.
* 연관관계의 주인만이 외래 키를 관리(등록, 수정)한다.
* 주인이 아닌쪽은 읽기만 가능하다.
* 주인이 아니면 mappedBy 속성으로 주인 지정한다.
* **외래 키가 있는 있는 곳을 주인으로 정한다.**

주의사항

* 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안된다.
* 양방향 매핑시 연관관계의 주인에 값을 입력해야 한다.
* **순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자**
  * 연관관계 편의 메소드를 생성하자



## 상속관계 매핑

* 관계형 데이터베이스는 상속 관계가 없다.
* 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다.
* 따라서  DB의 슈퍼타입 서브타입을 이용해 객체의 상속을 매핑한다.
* 조인전략, 단일 테이블 전략, 구현 클래스마다 테이블 전략 총 3가지 방법이 존재한다.

**조인 전략**

장점

* 테이블 정규화
* 외래 키 참조 무결성 제약조건 활용가능
* 저장공간 효율

단점

* 조회시 조인을 많이 사용해 성능이 저하된다.
* 조회 쿼리가 복잡하다
* 데이터 저장시 INSERT SQL 2번 호출된다.



**단일 테이블 전략**

장점

- 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
- 조회 쿼리가 단순함 • 단점

단점

* 자식 엔티티가 매핑한 컬럼은 모두 null 허용
* 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수. 있다.상황에 따라서 조회 성능이 오히려 느려질 수 있다.



**구현 클래스마다 테이블 전략**

* **이 전략은 데이터베이스 설계자와** **ORM** **전문가 둘 다 추천****X**

장점

* 서브 타입을 명확하게 구분해서 처리할 때 효과적
* not null 제약조건 사용 가능 • 단점

단점

* 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요)
* 자식 테이블을 통합해서 쿼리하기 어려움



### @Inheritance

| strategy 속성에 사용 가능한 전략 | 설명                        |
| -------------------------------- | --------------------------- |
| JOINED                           | 조인 전략                   |
| SINGLE_TABLE                     | 단일 테이블 전략            |
| TABLE_PER_CLASS                  | 구현 클래스마다 테이블 전략 |

### @DiscriminatorColumn

### @DiscriminatorValue



## @MappedSuperclass

* 공통 매핑 정보가 필요할 때 사용한다.
* 엔티티가 아니기 때문에 테이블과 매핑하지 않는다.
* 부모 클래스를 상속 받는 **자식 클래스에 매핑 정보만 제공한다**
* 상속관계 매핑이 아니다.
* 직접 생성해서 사용할 일이 없으므로 **추상 클래스 권장한다**
* 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할을 한다.
  * 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용한다.



**출처**

* [자바 ORM 표준 JPA 프로그래밍 - 기본편](

