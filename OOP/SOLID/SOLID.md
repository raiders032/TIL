# SOLID

* 소프트웨어 설계를 이해하기 쉽고 유연하고 유지보수하기 쉽게 만들기 위해 사용되는 원칙 5가지를 뜻한다.
* 5가지 원칙
  * Single Responsibility Principle(단일 책임 원칙)
  * Open-Closed Principle(개방-폐쇄 원칙)
  * Liskov Substitution Principle(리스코프 치환 원칙)
  * Interface Segregation Principle(인터페이스 분리 원칙)
  * Dependency Inversion Principle(의존 역전 원칙)



## SOLID를 언제 적용할까?

* SOLID는 디커플링을 중요하게 여기니 대규모 프로젝트일수록 유용하다 따라서 모든 프로젝트에 적용할 수 있다고 생각하지 말자
* 많은 프로젝트의 시작은 직접적/구체적인 설계로 시작하고 규모가 커지면서 유연성이 필요해지면 SOLID를 고려해봐도 좋다



## Single Responsibility Principle

> 한 클래스는 단 한기자의 변경 이유만을 가져야 한다. 한 클래스를 변경하기 위한 한 가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한 가지 이상의 책임을 맡고 있는 것이다. 

* SRP에서 책임은 `변경을 위한 이유`로 정의한다.
* 코드를 보는 대부분의 사람들이 이해할 수 있는 크기로 클래스를 만들자!



## Open-Closed Principle

> 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

* 애플리케이션의 요구사항이 변결될 때, 이 변경에 맞게 새로운 행위를 추가해 모듈을 확장 할 수 있다.
* 어떤 모듈의 행위를 확장하는 것이 그 모듈의 소스 코트나 바이너리 코드릐 변경을 초래하지 않는다.
* 어떻게 이것이 가능할까?
* 정답은 추상화!
  * 모듈이 추상화에 의존하면 수정에 대해 닫혀 있을 수 있다.
  * 그 모듈의 행위는 추상화의 새 파생 클래스를 만듦으로써 확장이 가능하다
* 단점
  * OCP를 따르자면 비용이 든다. 적절한 추상화를 만들기 위해서는 개발 시간과 노력뿐만 아니라 이런 추상화는 소프트웨어 설계의 복잡성을 높이기도 한다.
  * 개발자가 감당할 수 있는 추상화의 정도에는 한계가 있기 때문이다.
* 지나치고 불필요한 추상화로 설계에 부하를 주지 않으려면 추상화가 실제로 필요할 때까지 기다렸다가 사용하는 편이 좋다.



## Liskov Substitution Principle

> 서브타입은 그것의 기반 타입으로 치환 가능해야 한다.

* 부모가 할 수 있었던 일은 자식도 다 할 수 있어야 한다는 것을 의미한다.



## Interface Segregation Principle

* 큰 인터페이스 몇 개 보다 작은 인터페이스가 많은 것이 좋다.



## Dependency Inversion Principle

> 상위 수준의 모듈은 하의 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
>
> 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.











